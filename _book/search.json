[{"path":"index.html","id":"bienvenue","chapter":"Bienvenue!","heading":"Bienvenue!","text":"Bienvenue dans la version préliminaire et en ligne du livre Méthodes Quantitatives avec R de P.-O. Caron. Le livre porte sur la programmation statisitque en R et vise à révéler les mécanismes secrets des logiciels statistiques afin de les rendre accessibles au plus grand nombre de personnes. Ainsi, le livre tente de faire le pont entre statistiques et programmation pour les expérimentateurs. Il vise un public autant intéressé à s’initier à R qu’à en connaître davatange sur la statistique.Si vous avez des commentaires ou des suggestions, n’hésitez pas à les partager. C’est ouvrage est en construction. Il n’est pas parfait et peut contenir (contient!) des erreurs. Vous pouvez m’écrire à l’adresse suivante : pier-olivier[]teluq.ca pour toutes suggestions d’amélioration.","code":""},{"path":"index.html","id":"remerciements","chapter":"Bienvenue!","heading":"Remerciements","text":"Les étudiants et étudiantes de la classe PSY7105 d’automne 2021.","code":""},{"path":"préface.html","id":"préface","chapter":"Préface","heading":"Préface","text":"Les boîtes noires","code":""},{"path":"commencer-avec-r.html","id":"commencer-avec-r","chapter":" 1 Commencer avec R","heading":" 1 Commencer avec R","text":"R (R Core Team, 2021) est un logiciel de programmation statistique libre-accès et un environnement pour la computation statistique et l’affichage graphique. Il s’agit d’un projet GNU qui est similaire au langage et à l’environnement S, développés aux Laboratoires Bell (anciennement &T, aujourd’hui Lucent Technologies) par John Chambers. Créé par Ross Ihaka et Robert Gentleman, R fournit une grande variété de techniques statistiques (modélisation linéaire et non linéaire, analyses statistiques classiques, analyse de séries chronologiques, classification) et graphiques, et est hautement extensible.R est un logiciel basé sur la syntaxe plutôt qu’une approche pointer-et-cliquer (point--click) comme les logiciels traditionnels. Il peut être plus effrayant ou apparaître trop complexe pour un nouvel utilisateur, mais une fois apprivoisée, cette bête démontre un bien meilleur potentiel que ce soit en automatisation, en personnalisation, en production de figure de haute qualité, etc. R l’avantage de mettre en plein contrôle ses utilisateurs. Bref, c’est une créature qu’il vaut la peine de maîtriser.Les logiciels traditionnelles suspendent trop souvent la réflexion critique. Ils sont dociles. L’usager clique sur les bonnes options et obtient les résultats désirés (espérons-le!). En échange d’une expérience “simple et intuitive”, ils compromettent l’épanouissement de l’utilisateur et rendent l’analyse statistique comme une boîte noire, un programme dont le fonctionnement ne peut être connu. Sont évacuées toutes connaissances des analyses, seules les entrées et les sorties sont pertinentes.En se limitant à ces logiciels, les utilisateurs sont également à la merci des compagnies qui les distribuent. Par exemple, elles maintiennent des prix exorbitants pour des licences annuelles, malgré le faible soutien technique, la désuétude ou le manque de mise à jour, la présence de bogues informatiques. Ces problèmes sont monnaie courante bien que la licence ne soit pas de la petite monnaie.Contrairement aux logiciels traditionnels, R permet de réaliser les analyses, mais aussi de les programmer soi-même, de générer des données propres à un modèle, de rester à jour sur les nouvelles tendances et les découvertes en méthodologie de la recherche, de partager aisément les connaissances et la reproduction d’analyses sophistiquées, et tout cela, gratuitement. Évidemment, cela n’est possible que par l’immense communauté derrière le logiciel.","code":""},{"path":"commencer-avec-r.html","id":"pourquoi-r","chapter":" 1 Commencer avec R","heading":"1.1 Pourquoi R?","text":"R est complètement gratuit. Il est le logiciel le plus utilisé parmi les scientifiques de sciences de données, statisticiens, etc. Il est l’exemple ultime d’une plateforme communautaire qui fait mieux que les compétiteurs commerciaux. De plus en plus de personnes migrent vers R, mais peu de ses utilisateurs quittent le logiciel vers un autre. Et plus de personnes se joignent à la communauté, plus il y de documentation, d’aide, de soutien, que ce soit sous forme de livres, de vidéos, d’article, d’ateliers, de formations. L’expérience R devient de plus en plus accessible aux nouveaux immigrants. Comme le code source est ouvert, ses utilisateurs collaborent à la création de modules augmentant ses capacités qui permettent de résoudre des problèmes de plus en plus sophistiqués (et pas juste en statistiques!). Ces modules sont également gratuits et il y en littéralement des milliers.L’avantage de maîtriser R, plus spécifiquement de l’utilisation de syntaxe, pour l’expérimentateur est de rendre l’analyse statistique facilement transmissible entre expérimentateur (facilite grandement la collaboration), reproductible (vérification et collaboration), répétable (pour de nouvelles données ou expériences), et ajustable (pour de nouveaux scénarios). Quelqu’un d’autre peut jeter un oeil à l’analyse réalisée et voir exactement ce qui s’est produit, tant dans la gestion du jeu de données que l’analyse et la génération de graphiques. L’analyse peut être reproduite par les pairs, voire répéter si des données supplémentaires ont été recueillies ou si une nouvelle expérience été réalisée.Même si R est un langage de programmation et que cela peut en intimider plus d’un, il est relativement intuitif à apprendre et assez simple d’utilisation dans la mesure où les ressources appropriées pour apprendre sont accessibles à l’utilisateur. L’apprentissage de la programmation, même si ce n’est pas en R, permet de mieux comprendre le fonctionnement des ordinateurs en plus de reconsidérer le dogmatisme de tout-puissant “algorithmes”. Il permettra aussi à l’utilisateur lorsqu’il saura suffisamment maîtriser la bête à créer lui-même la syntaxe qu’il lui permettra de résoudre les problèmes sur lesquels il s’intéresse.Enfin, R possède un incroyable moteur pour la visualisation de données et de capacités graphiques. Aucun autre logiciel ne lui arrive à la cheville.","code":""},{"path":"commencer-avec-r.html","id":"installer-r","chapter":" 1 Commencer avec R","heading":"1.2 Installer R","text":"R est compatible pour Windows, Mac et Linux. Pour télécharger le logiciel, il faut se rendre sur le site http://www.r-project.org et sélectionner les hyperliens “download R” ou “CRAN mirror”. Il faut ensuite choisir un mirror de son pays d’origine. Par la suite, la page permet de choisir la version appropriée à son système d’exploitation. Il faut alors suivre les indications.Il est principalement utilisé en anglais bien qu’peut le définir en français. La plupart de l’aide sera également en anglais surtout celle pour les analyses avancées. Toutefois, il y beaucoup de ressources accessibles en ligne en français en ce qui attrait à l’initiation à R.","code":""},{"path":"commencer-avec-r.html","id":"rstudio","chapter":" 1 Commencer avec R","heading":"1.2.1 RStudio","text":"Bien que R puisse être utilisé seul, son aspect rudimentaire pourra en inquiéter plus d’un (surtout un.e étudiant.e en sciences humaines et sociales). Le logiciel RStudio permet une utilisation plus fluide et intuitive pour les usagers ayant peu ou pas d’expériences en programmation. RStudio est un environnement de développement intégré (IDE pour integrated development environment) pour R. Il comprend une console, un éditeur de mise en évidence de la syntaxe qui prend en charge l’exécution directe du code, ainsi que des outils de traçage, d’historique, de débogage et de gestion de l’espace de travail. Le logiciel est gratuit et libre-accès pour une utilisation personnelle. Il comporte aussi une version commerciale qui nécessite un certain déboursement de fonds.Pour télécharger le logiciel, il faut se rendre sur le site http:rstudio.com et naviguez jusqu’au téléchargement du logiciel, ou aller spécifiquement sur https://www.rstudio.com/products/rstudio/download/#download, où il sera possible de télécharger la version gratuite de RStudio. RStudio est uniquement disponible en anglais.","code":""},{"path":"commencer-avec-r.html","id":"les-avantages-de-rstudio","chapter":" 1 Commencer avec R","heading":"1.2.1.1 Les avantages de RStudio","text":"L’avantage de RStudio, comparativement à l’utilisation unique de R, est d’offrir une gestion de la console, du script, de l’environnement des variables et des documents externes en une seule interface (et beaucoup d’autres avantages!). En plus de la console (ce que R fournit), RStudio permet l’édition de syntaxe qui pourra être commandée ligne par ligne en utilisant CTRL + Enter (Windows) ou CMD + Enter (MacOS), ce qui pourra s’avérer fort utile lors de la programmation de fonction ou d’analyses de données. RStudio affiche également les variables en mémoire dans le menu Global Environment, ce qui permet de suivre l’état de la programmation. Enfin, RStudio affiche dans un quatrième menu les fichiers dans le directoire des fichiers R ce qui permet de voir notamment les jeux de données, mais aussi d’autres fonctions ou scripts. C’est également à cet endroit où l’aide (help) sera fournie et les figures (plot) affichées.Tout le contenu du présent ouvrage pourra être réalisé avec R ou avec RStudio, toutefois l’usage de ce dernier sera plus agréable aux lecteurs et lectrices.Oh! Une autre avantage de Rstudio est qu’il peut être utiliser comme un éditeur de texte. D’ailleurs, cet ouvrage est complètement rédigé avec RStudio (avec le package Rmarkdown).","code":""},{"path":"commencer-avec-r.html","id":"autres-options","chapter":" 1 Commencer avec R","heading":"1.2.2 Autres options","text":"Il existe plusieurs interfaces utilisateurs graphiques (GUI pour Graphical User Interface) pour R comme R Commander (certainement l’option la plus connue en sciences humaines et sociales) ou JASP, mais aussi plusieurs autres. Ces deux options sont gratuites et libre-accès. Il existe aussi d’autres options payantes. Ces logiciels visent l’utilisation de R par une approche pointer-et-cliquer (point--click) au travers les analyses plutôt que de recourir à la syntaxe. Ces options plus intuitives pour l’utilisateur sans expérience en programmation auront parfois des effets limitatifs pour des analyses plus avancées et ont comme effet indésirable de promouvoir la boîte noire statistique.","code":""},{"path":"commencer-avec-r.html","id":"démarrer-r-ou-rstudio","chapter":" 1 Commencer avec R","heading":"1.3 Démarrer R ou RStudio","text":"À l’ouverture de R, le logiciel présente la console, une interface très rudimentaire (et assez déstabilisante pour un logiciel pourtant si promu). Une fois le logiciel ouvert, l’application offre une invitation discrète à écrire des commandes. Le symbole > au bas de la console est une invite (prompt) indiquant où taper les commandes. C’est à cette ligne de commande que les expressions seront immédiatement évaluées.\nFigure 1.1: Ouverture (effrayante!) de la console R\nDans la Figure 1.1, R est défini en français. Cela n’pour effet que de modifier le menu déroulant (“Fichier, Edition, etc.”) au sommet du logiciel et les différentes options de ce menu. Le fonctionnement reste le même (les fonctions ne sont pas traduites, par exemple).La console R n’étant pas un éditeur de texte, il faudra enregistrer la syntaxe utilisée lors d’une séance pour la conserver. Le logiciel offre une option d’écriture de script intégré, mais n’est pas lié directement à la console. Il faudra donc se résoudre à abuser du copier-coller ou à sourcer le script (tâche plus ardue pour les nouveaux utilisateurs). Plusieurs éditeurs de texte sont utiles ou même construits pour directement travailler avec R, le plus connu étant certainement RStudio. L’environnement intégré sera beaucoup plus fonctionnel.La figure 1.2, montre l’interface de RStudio, déjà un peu moins intimidante que celle de R. À l’ouverture de RStudio, quatre types de fenêtres sont disponibles : la console (cadran inférieur gauche), les scripts (cadran supérieur gauche), l’environnement (cadran supérieur droit) et l’affichage (cadran inférieur droit). L’emplacement de ces cadrans peut être modifié selon les désirs de l’utilisateur.\nFigure 1.2: Ouverture (moins effrayante) de RStudio\nLa console RStudio est identique à la console usuelle retrouvée avec R. Elle sert les mêmes fonctions. Le script est un éditeur de texte dans lequel de la syntaxe sera rédigée, sauvegardée, manipulée, et tester. S’il n’est pas ouvert ou s’il faut ouvrir un script supplémentaire, il faut procéder par le menu déroulant.FileNew FileR Scriptou bien CTRL + Shift + N. Il peut y avoir plusieurs scripts ouverts simultanément. L’environnement global permet de connaître les variables et fonctions maison en mémoire vive. L’onglet History montre les dernières lignes de code commandées (non affichées dans la figure - il suffit de cliquer sur l’onglet à côté de Environment). Enfin, le cadran inférieur droit montre le fichier de travail R qui contiendra ordinairement les fichiers de travail actifs (scripts, jeu de données, fonctions maison, etc.) C’est très utile pour travailler par projet. Si aucun directoire n’est demandé explicitement par R (par exemple, si un jeu de donnée doit être téléchargé), le logiciel cherchera par défaut dans le fichier actif pour télécharger les fichiers demandés. Il est une bonne pratique que de s’assurer d’être dans le bon fichier, car cela pourra causer quelques soucis à l’occasion.","code":""},{"path":"programmer-avec-r.html","id":"programmer-avec-r","chapter":" 2 Programmer avec R","heading":" 2 Programmer avec R","text":"Dans les prochaines sections, les différents éléments de programmation permettant la création et la manipulation de données seront présentés.","code":""},{"path":"programmer-avec-r.html","id":"les-scripts","chapter":" 2 Programmer avec R","heading":"2.1 Les scripts","text":"Ce qu’il importe le plus avec R, mais où RStudio resplendit, est de conserver la syntaxe d’une session à l’autre, ce que le logiciel ne fait pas très bien. Il faudra sauvegarder dans un script les expressions et le code utilisés. Ces fichiers ont souvent comme extension “.R” et permettront de conserver, voire partager la syntaxe. Il sera possible d’y ajouter des commentaires pour de futures utilisations. Tout éditeur de texte peut permettre la sauvegarde de syntaxe, certains seront mieux que d’autres pour l’utilisation avec R.","code":""},{"path":"programmer-avec-r.html","id":"les-variables","chapter":" 2 Programmer avec R","heading":"2.2 Les variables","text":"Pour manipuler les données, il faut recourir à des variables. Afin de leur attribuer une valeur, il faut assigner cette valeur avec <- (ALT + -) ou =, par exemple,où est maintenant égale à 2. La première ligne assigne la valeur à . La deuxième ligne, indique à la console R d’imprimer le résultat pour le voir. Par la suite, pourra être utilisée dans des fonctions, des calculs ou analyses plus complexes. De surcroît, pourra devenir une fonction, une chaîne de caractère (string) ou un jeu de données.Conventionnellement, les puristes de R recommanderont l’usage de <- plutôt que = pour l’assignation. Il y quelques nuances computationnelles entre les deux, mais qui échapperont irrémédiablement aux néophytes et même aux usagers intermédiaires.Pour nommer des variables, seuls les caractères alphanumériques peuvent être utilisés ainsi que le tiret bas _ et le .. Les variables ne peuvent commencer par un nombre.Réassigner une valeur à une variable déjà existante écrase la valeur précédente.La sortie produit 3 et non plus 2.Cette remarque est importante, car elle signifie que l’peut écraser des fonctions en nommant des variables. Il faut ainsi éviter de nommer des variables avec des fonctions utilisées par R, évitera notamment l’utilisation des noms suivants.Certains mots seront tout simplement interdits d’utilisation.","code":"\na <- 2\na\n#> [1] 2\na <- 2\na <- 3\na\n#> [1] 3\nc; q; t; C; D; I; T; F; pi; mean; var; sd; length; diff; rep;TRUE; FALSE; break; for; in; if; else; while; function; Inf; NA; NaN; NULL;"},{"path":"programmer-avec-r.html","id":"les-opérateurs-arithmétiques","chapter":" 2 Programmer avec R","heading":"2.3 Les opérateurs arithmétiques","text":"La première utilisation qu’un nouvel usager fait de R est généralement d’y recourir comme calculatrice. pourra utiliser les opérateurs arithmétiques de base comme l’addition +, la soustraction -, la multiplication *, la division / , et l’exposant ^.Évidemment, ces opérateurs fonctionnent sur des variables numériques.Ici, les deux premières lignes assignent des valeurs à et b, puis imprime la division. L’absence de marqueur <- ou = indique à R d’imprimer la réponse dans la console. Si le résultat /b devait être assigné à une variable, alors aucun résultat ne serait affiché, bien que la variable contienne la réponse.Il n’y aucune réponse d’affichée. Maintenant, si resultat est demandé, R affiche le résultat.D’autres fonctions sont aussi très utiles. Par exemple, la racine carrée sqrt() (qui n’est rien d’autre que ^(1/2)) et le logarithme naturel log(). Il suffit d’insérer une variable ou une valeur à l’intérieur d’une de ces fonctions pour en obtenir le résultat.","code":"\n2 + 2\n#> [1] 4\n1 / 3\n#> [1] 0.33\n2 * 3 + 2 ^ 2\n#> [1] 10\na <- 1\nb <- 10\na / b\n#> [1] 0.1\nresultat <- a / b\nresultat\n#> [1] 0.1\nsqrt(4)\n#> [1] 2\n4^(1/2)\n#> [1] 2\nlog(4)\n#> [1] 1.4"},{"path":"programmer-avec-r.html","id":"les-commentaires","chapter":" 2 Programmer avec R","heading":"2.4 Les commentaires","text":"Les scripts R peuvent contenir des commentaires. Ceux-ci sont désignés par le désormais célèbre #. Une ligne de script commençant par ce symbole sera ignorée par la console. Ces commentaires permettent aussi bien de préciser différentes étapes d’un script, que d’expliquer la nomenclature des variables ou encore d’expliquer une fonction, ses entrées, ses sorties. Les commentaires sont extrêmement utiles, car les annotations peuvent souvent sauver énormément de temps et d’effort lors d’utilisations ultérieures.Dans cet exemple, la première ligne est ignorée. Autrement, la console R produirait une erreur, car cette ligne est pour le logiciel pur charabia!","code":"\n# la variable resultat est le quotient des variables a et b\nresultat <- a / b\nresultat\n#> [1] 0.1"},{"path":"programmer-avec-r.html","id":"définir-une-chaîne-de-caractère","chapter":" 2 Programmer avec R","heading":"2.5 Définir une chaîne de caractère","text":"La plupart du temps, les variables utilisées seront numériques, c’est-à-dire qu’elles contiendront des nombres. Parfois en analyses de données, il pourra s’agir de chaîne de caractères (string), autrement dit, de mots. Les chaînes de caractères sont définis par le double apostrophe \"...\", où remplace les trois points par les mots désirés.","code":"\ntitre <- \"Bonjour le monde!\"\ntitre\n#> [1] \"Bonjour le monde!\""},{"path":"programmer-avec-r.html","id":"concaténer","chapter":" 2 Programmer avec R","heading":"2.6 Concaténer","text":"Une fonction fort utile permettra de joindre des données dans une seule variable. Précédemment, l’assignation d’une valeur des variables se limitait qu’à une chaîne de caractères ou une valeur numérique. Pour mettre plusieurs éléments (deux ou plus) dans une seule variable, la fonction concaténée c() (ou combiner, créer) suffira à la tâche. Il faudra délimiter chaque élément par une virgule ,.Elle fonctionne également avec les chaînes de caractères.Et les deux.Il faudra faire attention à ce qui est passé comme argument à la fonction c(), car elle ne crée que des vecteurs (une ligne en quelque sorte) avec les entrées fournies, peu importe leur structure de départ. Par exemple, un jeu de données passant par c() devient une seule ligne de valeurs. Les fonctions cbind() et rbind() permettront de joindre des colonnes et des lignes respectivement.","code":"\nvaleurs <- c(-5, 5)\nvaleurs\n#> [1] -5  5\ntexte <- c(\"Allo\", \"le monde\")\ntexte\n#> [1] \"Allo\"     \"le monde\"\nphrase <- c(1,\"Chat\", 2,\"Souris\")\nphrase\n#> [1] \"1\"      \"Chat\"   \"2\"      \"Souris\""},{"path":"programmer-avec-r.html","id":"référer-à-des-sous-éléments","chapter":" 2 Programmer avec R","heading":"2.7 Référer à des sous-éléments","text":"Avec des variables contenant plusieurs valeurs, il peut être utile de référer à une seule valeur ou un ensemble de valeurs de la variable. Les crochets [] à la suite du nom d’une variable permettront d’en extraire les valeurs désirées sans tout sortir l’ensemble.Dans le premier exemple, seul un élément est demandé. Dans le deuxième exemple, la commande 1:3 produit la série de \\(1,2,3\\) et en extrait ces nombres. Dans le dernier exemple, la fonction c() est astucieusement utilisée pour extraire les éléments \\(2\\) et \\(4\\). Le quatrième exemple montre comment retirer un élément en utilisant des valeurs négatives et le cinquième exemple montre comment retirer des éléments.","code":"\nphrase <- c(1,\"Chat\", 2,\"Souris\")\n# Extraire le premier élément de la variable phrase\nphrase[1]\n#> [1] \"1\"\n# Extraire les éléments 1, 2 et 3\nphrase[1:3]\n#> [1] \"1\"    \"Chat\" \"2\"\n# Extraire les éléments 2 et 4\nphrase[c(2,4)]\n#> [1] \"Chat\"   \"Souris\"\n# Ne pas extraire l'élément 1\nphrase[-1]\n#> [1] \"Chat\"   \"2\"      \"Souris\"\n# Ne pas extraire les éléments 1 et 3\nphrase[-c(1,3)]\n#> [1] \"Chat\"   \"Souris\""},{"path":"programmer-avec-r.html","id":"les-fonctions","chapter":" 2 Programmer avec R","heading":"2.8 Les fonctions","text":"R offre une multitude de fonctions et permet également à l’usager de bâtir ses propres fonctions (fonctions maison). Elles permettent d’automatiser des calculs (généralement, mais peut faire beaucoup plus!). Tout au long de cet ouvrage, les fonctions seront identifiées par l’ajout de parenthèse à leur fin, comme ceci : function(). Ces fonctions ont généralement la forme suivante.Ici, nom est le nom auquel la fonction sera référée par la suite, function est la fonction R qui permet de créer la fonction maison, argument1 et argument2 sont les arguments (les entrées) fournis à la fonction et à partir desquels les calculs seront réalisés, et les accolades {} définissent le début et la fin de la fonction dans le script.Il sera bien utile de créer ses propres fonctions bien que R possède une pléthore de fonctions et de packages en contenant encore plus. Toutes les fonctions, qu’elles soient maisons ou déjà intégrées, respectent le même fonctionnement, ce pour quoi il est utile de s’y pencher. Les fonctions maison permettront d’automatiser certains calculs qui seront propres à résoudre les problèmes de l’usager et d’être réutilisé ultérieurement.Voici un exemple trivial de fonction. Ici la somme de deux nombres.Par défaut, une fonction retourne la dernière ligne calculée si elle n’est pas assignée à une variable. Si le résultat d’une fonction est assigné, la fonction ne retourne pas le résultat dans la console, mais assigne bel et bien la variable.Afin d’éviter ces problèmes ou s’il fallait retourner plusieurs arguments (ce qui sera souvent le cas!), il faudrait utiliser la fonction return() à la fin de la fonction.","code":"\nnom <- function(argument1, argument2, ...) {\n  # Calcul à réaliser\n}\naddition <- function(a, b) {\n  a + b\n}\naddition(2,3)\naddition2 <- function(a, b) {\n  # Le résultat est assigné à une variable\n  somme <- a + b\n}\n# Ne produit pas de sortie\naddition2(100, 241)\n# Comme il y a assignation, total n'est pas affichée\ntotal <- addition2(100, 241)\n# En roulant total, la sortie affiche bien la sortie de addition2()\ntotal\n#> [1] 341\naddition3 <- function(a, b) {\n  # Le résultat est assigné à une variable\n  somme <- a + b\n  return(somme)\n}\n# Les deux fonctions produisent une sortie\naddition3(4, 6)\n#> [1] 10\ntotal <- addition3(4, 6)\ntotal\n#> [1] 10"},{"path":"programmer-avec-r.html","id":"définir-une-boucle","chapter":" 2 Programmer avec R","heading":"2.9 Définir une boucle","text":"Pour automatiser certains calculer, il peut être utile de recourir à une boucle (loop) qui pourra répéter plusieurs fois une même opération. Voici l’anatomie d’une boucle.L’élément est la fonction déclarant la boucle. Les renseignements sur les itérations se retrouvent entre les parenthèses. La variable prendra successivement tous les éléments dans () le vecteur à gauche (vec). Tout le contenu de la boucle (ce qui sera répété) se retrouve entre les accolades {}, c’est ce qui sera produit à chaque boucle. Dans cet exemple, la boucle se répète \\(k\\) fois, soit de \\(1,2,3,...,k\\), à cause de l’expression 1:k qui correspond à générer un vecteur de \\(1\\) à \\(k\\). La variable quant à elle change de valeur à chaque itération. Elle prendra tour à tour ces valeurs chaque itération \\(1,2,3,...,k\\). La variable pourra judicieusement être utilisée dans la boucle afin de profiter ce comportement, notamment pour le classement des résultats. Lorsque la boucle atteint \\(k\\), elle se termine.Il est aussi possible de rédiger la boucle en utilisant uniquement k. Alors, prendra toutes les valeurs contenues dans k. La longueur du vecteur k définit le nombre d’itérations.","code":"\nfor(i in vec){\n  # Calcul désiré\n}\nfor(i in k){\n  # Calcul désiré\n}"},{"path":"programmer-avec-r.html","id":"définir-des-clauses-conditionnelles","chapter":" 2 Programmer avec R","heading":"2.10 Définir des clauses conditionnelles","text":"Pour réaliser des opérations sous certaines conditions ou opérer des décisions automatiques, il est possible d’utiliser des arguments conditionnels avec des opérateurs logiques. Par exemple, sélectionner des unités ayant certaines caractéristiques, comme les participants ayant 18 ans et moins, les personnes ayant un trouble du spectre de l’autiste, ou encore par sexe. Il est aussi possible d’utiliser les opérateurs pour définir à quelle condition telle ou telle autre fonction doit être utilisée. Il faudra alors utiliser les arguments logiques.\nTable 2.1: Symboles logiques et leur signification\nR teste si les valeurs de la variable correspondent à l’opérateur logique en les déclarant comme vraies (TRUE) ou fausses (FALSE).Cela peut être utilisé pour référer à des sous-éléments comme abordés précédemment.Ici, toutes les valeurs vraies de l’opérateur logique sont rapportées.Les opérateurs logiques servent également à définir des opérations conditionnelles. La fonction sera alors utilisée. Il y trois principales formes : (Si ceci, alors cela), le  else (Si ceci, alors cela, sinon autre chose) et les échelles else else.L’anatomie d’une fonction comporte d’abord la fonction . L’argument entre parenthèses à sa plus simple expression doit être vérifié par vrai (TRUE) ou faux (FALSE). Si l’argument est vrai, alors le calcul désiré est réalisé, autrement le logiciel ignore le calcul de la fonction entre accolades {}.Il est possible d’élaborer cette logique avec la fonction else qui permet de spécifier une suite à la fonction si l’argument est faux (FALSE).Enfin, il est possible d’élaborer un arbre de décision avec toute une échelle de conditionnels.L’arbre de décision peut devenir aussi compliqué que l’utilisateur le désire : chacune des branches peut contenir autant de ramifications que nécessaire.Il peut arriver pour certaines fonctions de devoir spécifier si certains paramètres sont vrais (TRUE) ou faux (FALSE) ou de définir des variables ayant ces valeurs. Lorsque c’est le cas, il est toujours recommandé d’écrire les valeurs logiques tout au long comme TRUE et FALSE, même si R reconnaît T et F, car ces dernières peuvent être réassignées, contrairement aux premières.","code":"\nvaleurs <- 1:6\n# Toutes les valeurs plus grandes que 3.\nvaleurs > 3\n#> [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\nvaleurs <- 1:6\n# Toutes les valeurs plus grandes que 3.\nvaleurs[valeurs > 3]\n#> [1] 4 5 6\nif(x){\n  # Opération désirée\n}\nx <- -2\nif(x < 0){\n  print(\"la valeur est négative\")\n}\n#> [1] \"la valeur est négative\"\nx <- 2\nif(x < 0){\n  print(\"la valeur est négative\")\n}else{\n  print(\"la valeur est positive\")\n}\n#> [1] \"la valeur est positive\"\nx <- 0\nif(x < 0){\n  print(\"la valeur est négative\")\n}else if(x > 0){\n  print(\"la valeur est positive\")\n}else{\n  print(\"la valeur est égale à 0\")\n}\n#> [1] \"la valeur est égale à 0\""},{"path":"programmer-avec-r.html","id":"les-packages","chapter":" 2 Programmer avec R","heading":"2.11 Les packages","text":"L’utilisation de packages (souvent nommées bibliothèques, modules, paquets ou paquetage en français - ici, l’usage de package sera maintenu) est l’attrait principal de R. Pour éviter l’anglicisme, Antidote suggère forfait, achat groupé ou progiciel (ce dernier étant certainement le terme approprié).Les packages sont de regroupement de fonctions. C’est certainement l’aspect qui le plus contribué au succès et à sa dissémination de R. Il s’agit de la mise en commun d’un effort collaboratif afin de créer des fonctions et de les partager librement entre les usagers. Le téléchargement de base de R offre déjà quelques packages rudimentaires (comme base qui offre des fonctions comme sum() ou stat qui offre des fonctions comme mean() et var()), mais qui suffisent rarement lorsque des analyses plus avancées ou plus spécialisées sont nécessaires.L’une des forces des packages est qu’ils sont fournis généralement avec un bon manuel d’utilisation. Plusieurs contributeurs leur sont associés (avec un responsable). Ils sont maintenus régulièrement. Le soutien des responsables est parfois aisé à obtenir et les auteurs de ces packages sont motivés à maintenir les packages opérationnels et aux bénéfices de tous. La faiblesse des packages est qu’il s’agit malheureusement de généralement. Il arrive que certains packages produisent des erreurs de calcul, soient laissé en désuétude par leurs auteurs, que le package ait migré sous une autre forme, que de meilleures options soient disponibles sans aucune notice à cet effet. Cela va sans dire, ce problème concerne les logiciels traditionnels également. Il s’agit toutefois d’un enjeu moindre, car les packages sont souvent recommandés par des collègues, des autorités dans leur domaine respectif ou des ouvrages de référence, ce qui aura comme tendance de promouvoir les meilleurs packages. Pas toujours. Il faut rester critique et ne pas de laisser tromper par une boîte noire.Une dernière faiblesse : les packages agissent parfois en boîte noire, c’est-à-dire qu’ils court-circuitent la réflexion de l’utilisateur qui leur fait confiance. Il peut être parfois difficile de savoir ce que les fonctions produisent exactement. Au contraire des logiciels traditionnels, ces boîtes noires peuvent dans la plupart des cas être accessibles directement, elles sont liés en plus à des articles scientifiques ou de la documentation qui permet dans comprendre les tenants et aboutissants.","code":""},{"path":"programmer-avec-r.html","id":"installer-des-packages","chapter":" 2 Programmer avec R","heading":"2.11.1 Installer des packages","text":"Pour installer un package, il faut utiliser la fonctionoù les \"...\" doivent être remplacé par le nom du package. Il est important de bien inscrire le nom du package entre guillemet anglophone. Il est aussi possible de sélectionnerTools;Install Packages…puis de nommer le package sous l’onglet package. Avec R il faudra auparavant choisir un miroir (sélectionner un pays), ce qui ne sera pas nécessaire avec RStudio. Une fois téléchargé, il ne sera plus nécessaire de refaire cette étape à nouveau, à l’exception de potentielles et ultérieures mises à jour lorsqu’elles devront être réalisées.","code":"\ninstall.packages(\"...\")"},{"path":"programmer-avec-r.html","id":"appeler-un-package","chapter":" 2 Programmer avec R","heading":"2.11.2 Appeler un package","text":"Ce qui n’est pas des plus intuitif avec R, c’est qu’une fois le package téléchargé, il n’est pas directement utilisable. Il faut d’abord l’appeler avec la fonction library().Cette étape doit être faite à chaque ouverture de R. Cela permet de ne pas mettre en mémoire trop de package simultanément. Il sera ainsi important d’indiquer tous les packages utilisés en début de script sans quoi des erreurs comme l’absence de fonctions seront produites.Une technique à laquelle l’utilisateur peut avoir recourt lorsqu’il souhaite n’utiliser qu’une fonction spécifique d’un package est l’utilisation des :: débutant par le nom du package suivi par le nom de la fonction, comme MASS::mvrnorm(). La fonction s’utilise de façon usuelle. En utilisant ::, il n’est pas nécessaire d’appeler le package avec la fonction library(). Il faut toute fois que le package soit bel et bien installer.","code":"\nlibrary(\"...\")"},{"path":"programmer-avec-r.html","id":"obtenir-de-laide","chapter":" 2 Programmer avec R","heading":"2.12 Obtenir de l’aide","text":"En utilisant help(nom) ou ?nom, où il faut remplacer nom par le nom d’une fonction ou d’un package, R offre de la documentation. Les fonctions d’aide retournent une page de documentation contenant généralement de l’information sur les entrées et les sorties des fonctions. Certaines sont mieux détaillées que d’autres, tout dépendant de leurs créateurs et des personnes qui maintiennent ces fonctions.Il existe également la fonction ??nom qui produit une liste de toutes fonctions R ayant partiellement l’inscription introduite à la place de nom. Aussi, example(nom) produit un exemple d’une fonction.","code":"\n# Obtenir de l'aide pour la fonction help()\n?help"},{"path":"programmer-avec-r.html","id":"en-cas-de-pépins","chapter":" 2 Programmer avec R","heading":"2.13 En cas de pépins…","text":"Il arrive parfois que le code utilisé ne fonctionne pas, que des erreurs se produisent ou que des fonctions fort utiles demeurent inconnues. Même après plusieurs années d’utilisation, les utilisateurs font encore quotidiennement des erreurs (au moins une!). Un excellent outil est d’utiliser un moteur de recherche dans un fureteur de prédilection, de poser une question à l’aide de quelques mots clés bien choisis, préférablement en anglais, et en y inscrivant “R” ou “R” ou “R”. La plupart du temps, les programmeurs de packages auront une solution sur leur site ou leurs instructions de packages. Il y aussi des plateformes publiques et en ligne, comme StackOverflow qui collectent questions et réponses sur le codage. D’autres utilisateurs peuvent avoir posé la même question et des auteurs de programmes R et d’autres usagers y auront répondu aux bénéfices de tous. Dans le cas d’une solution introuvable, ces mêmes plateformes permettent de poser de nouvelles questions. Il faudra toutefois attendre qu’un usager plus expérimenté prenne le temps d’y répondre.","code":""},{"path":"fonctions-statistiques-essentielles.html","id":"fonctions-statistiques-essentielles","chapter":" 3 Fonctions statistiques essentielles","heading":" 3 Fonctions statistiques essentielles","text":"Dans cette section, des fonctions utilisées couramment seront présentées. L’accent est mis sur la définition de la fonction (qu’est-ce qu’elle calcule?), le développement d’une fonction maison (rédigée par l’usager pour la mettre en pratique) et l’identification de la fonction déjà implantée en R.","code":""},{"path":"fonctions-statistiques-essentielles.html","id":"la-longueur","chapter":" 3 Fonctions statistiques essentielles","heading":"3.1 La longueur","text":"La longueur d’une variable correspond au nombre d’éléments qu’elle contient. La fonction length() permettra d’obtenir ce résultat. Il sera particulièrement utile lorsqu’il faudra calculer, par exemple, la taille d’échantillon (le nombre d’unités d’observation d’une variable).La somme d’une chaîne de caractère est toujours de \\(1\\), peu importe le nombre de caractères. La fonction nchar() produira le nombre de caractères.Une variable qui existe, mais qui ne contient pas de valeur aura une longueur égale \\(0\\). Ce type de variable est utile lorsqu’il faut créer une variable qui aura une taille variable.","code":"\nx <- c(1,2,3)\nlength(x)\n#> [1] 3\n\ny <- \"Bonjour le monde!\"\nlength(y)\n#> [1] 1\n\nnchar(y)\n#> [1] 17"},{"path":"fonctions-statistiques-essentielles.html","id":"la-somme","chapter":" 3 Fonctions statistiques essentielles","heading":"3.2 La somme","text":"Il sera très fréquent de devoir calculer des sommes de variables pour en obtenir le total. En tant qu’humain, le calcul d’une série de nombre correspond à prendre chaque nombre et de les additionner un à un. La fonction suivante reproduit assez bien ce qu’un humain ferait (avec ses quelques caprices de programmation tel que devoir déclarer l’existence de la variable de total et spécifier le nombre d’éléments à calculer).À noter que l’utilisation de la boucle est à des fins illustratives uniquement. En termes de rendement computationnel, elle est bien peu efficace. Il faudra privilégier la fonction sum() pour calculer le total de son entrée.Il faut prendre garde : R calcule le total de tous les éléments de l’entrée sans égard aux lignes et aux colonnes. Si deux variables étaient entrées par inadvertance, alors R calculerait la somme de ces deux variables plutôt que de retourner deux totaux. À cette fin, les fonctions rowSums() et colSums() seront utiles lorsqu’il faudra calculer des sommes sur des lignes (row) ou des colonnes (col).","code":"\nsomme <- function(x){\n  n <- length(x)\n  total <- 0\n  for(i in 1:n){\n    # Prendre le ie élément et l'additionner\n    # au total des (i-1)e éléments précédents\n    total <- total + x[i]\n  }\n  return(total)\n}\nx <- c(1,2,3,4,5,-6)\nsomme(x)\n#> [1] 9\nsum(x)\n#> [1] 9"},{"path":"fonctions-statistiques-essentielles.html","id":"la-moyenne","chapter":" 3 Fonctions statistiques essentielles","heading":"3.3 La moyenne","text":"La moyenne est une mesure de tendance centrale qui représente le centre d’équilibre d’une distribution (un centre de gravité en quelque sorte). Si le poids d’un des côtés d’une distribution de probabilité était altéré (plus lourde ou plus légère), alors la moyenne se déplacerait en conséquence.La moyenne d’un échantillon correspond à la somme de toutes les unités d’une variable divisée par le nombre de données de cette variable ou, mathématiquement, \\[\\bar{x}=\\frac{\\Sigma_{=1}^n x}{n} \\] où \\(x\\) est la variable, \\(n\\) est le nombre d’unité et \\(\\Sigma_i^n\\) représente la somme de toutes les unités de \\(x\\). R possède déjà une fonction permettant de calculer la moyenne sans effort, mean() où l’argument est la variable. Il est également possible de développer une fonction maison pour calculer la moyenne commeoù sum(x) calculer la somme de toutes les unités de x, / permet la division et length(x) calculer le nombre d’unité dans la moyenne.\nPar exemple, à partir d’une variable x, les fonctions suivantes donnent le même résultat. Par contre la fonction mean() est beaucoup plus robuste que cette dernière équation.Comme pour sum(), les fonctions rowMeans() et colMeans() seront utiles lorsqu’il faudra calculer des moyennes sur des lignes (row) ou des colonnes (col).","code":"\nx_bar <- sum(x)/length(x)\n# Création de la variable\nx <- c(0, 1, 2, 3, 4, 5)\n# La moyenne\nmean(x)\n#> [1] 2.5\n# La moyenne\nsum(x)/length(x)\n#> [1] 2.5"},{"path":"fonctions-statistiques-essentielles.html","id":"la-médiane","chapter":" 3 Fonctions statistiques essentielles","heading":"3.4 La médiane","text":"La médiane d’un échantillon correspond à la valeur où \\(50\\%\\) des données se situe au-dessous et au-dessus de cette valeur. C’est la valeur au centre des autres (lorsqu’elles sont ordonnées). Quand le nombre de données est impair, le \\(\\frac{(n+1)}{2}\\)e élément est la médiane. Quand le nombre est pair, la moyenne des deux valeurs au centre correspond à la médiane. Cette statistique est intéressante comme mesure de tendance centrale, car elle est plus robuste aux valeurs aberrantes (moins sensibles) que la moyenne .Évidemment, R offre déjà une fonction median() pour réaliser le calcul. Il est toutefois possible de programmer une fonction maison. Il faudra utiliser la fonction sort() pour ordonner les données (croissant par défaut).L’expression n%%2, lue \\(n \\bmod 2\\), joue astucieusement le rôle de vérifier si n est impaire. La formule générale \\(x \\bmod y\\) représente une opération binaire associant à deux entiers naturels le reste de la division du premier par le second. Par exemple, \\(60 \\bmod 7\\), noter 60%%7 dans R, donne \\(4\\) soit le reste de \\(7*8 + 4 = 60\\). Le logiciel le confirme.Il s’agit d’une technique de programmation très pratique. Dans le cas de n%%2, la formule donne \\(1\\) dans le cas d’un nombre impair ou \\(0\\) dans le cas d’un nombre pair, puis teste ce résultat pour déterminer s’il réalise s[(n+1)/2] lorsque n%%2==1(TRUE) , ce qui correspond à choisir l’élément au centre d’un vecteur de taille impair, ou bien mean(s[n/2+0:1] lorsque n%%2==0(FALSE) , ce qui correspond à choisir les deux éléments au centre d’un vecteur pair et d’en faire la moyenne. Il s’agit de l’une des nombreuses façons selon lesquelles il est possible de programmer la médiane.","code":"\nmediane <- function(x) {\n  n <- length(x)\n  s <- sort(x)\n  ifelse(n%%2 == 1, s[(n + 1) / 2], mean(s[n / 2 + 0:1]))\n}\n# Tester ensuite:\nx <- c(42, 23, 53, 77, 93, 20, 37, 24, 60, 62)\nmedian(x)\n#> [1] 48\nmediane(x)\n#> [1] 48\n60%%7\n#> [1] 4"},{"path":"fonctions-statistiques-essentielles.html","id":"la-variance","chapter":" 3 Fonctions statistiques essentielles","heading":"3.5 La variance","text":"La variance d’un échantillon est une mesure de dispersion. Elle représente la somme des écarts (distances) par rapport à la moyenne au carré divisée par la taille d’échantillon moins \\(1\\). Mathématiquement, il s’agit de l’équation (3.1).\\[\ns^2 = \\frac{1}{n-1}\\sum_{=1}^n(x_i-\\bar{x})^2\n\\tag{3.1}\n\\]\nIl est assez aisé d’élaborer une fonction pour réaliser se calculer avec les fonctions déjà abordées.La variance peut aussi être calculée plus efficacement avec la fonction R var().","code":"\nvariance <- function(x){\n  n <- length(x)\n  xbar <- mean(x)\n  variance <- sum((x - xbar) ^ 2)/(n - 1)\n  return(variance)\n}\nx <- c(26, 6, 40, 36, 14, 3, 21, 48, 43, 2)\nvariance(x)\n#> [1] 300\nvar(x)\n#> [1] 300"},{"path":"fonctions-statistiques-essentielles.html","id":"lécart-type","chapter":" 3 Fonctions statistiques essentielles","heading":"3.6 L’écart type","text":"L’écart type d’un échantillon représente la racine carrée de la variance. Elle une interprétation plus intuitive en tant que mesure de la moyenne des écarts par rapport à la moyenne. Si le calcul avait été entrepris avec les distances par rapport à la moyenne (au lieu des écarts au carré), alors la somme serait toujours de 0, un résultat tout à fait bancal. En prenant la racine carrée des écarts au carré, ce qui constitue une mesure de distance euclidienne, l’écart type devient une mesure de l’étalement de la dispersion autour du centre d’équilibre.\\[\ns =\\sqrt{s^2}= \\sqrt{\\frac{1}{n-1}\\sum_{=1}^n(x_i-\\bar{x})^2}\n\\]\nAvec R, la fonction de base est sd(). Il est possible de récupérer la fonction maison précédemment rédigée.","code":"\necart.type <- function(x){\n  et <- sqrt(variance(x))\n  return(et)\n}\necart.type(x)\n#> [1] 17\nsd(x)\n#> [1] 17"},{"path":"fonctions-statistiques-essentielles.html","id":"les-graines","chapter":" 3 Fonctions statistiques essentielles","heading":"3.7 Les graines","text":"Par souci de reproductibilité, il est possible de déclarer une valeur de départ aux variables pseudoaléatoires, ce que l’nomme une graine ou seed en anglais. Cela permet de toujours d’obtenir les mêmes valeurs à plusieurs reprises, ce qui est très utile lors d’élaboration de simulations complexes ou lorsque des étudiants essaient de répliquer résultat tiré d’un ouvrage pédagogique.Il suffit de spécifier cette commande (en remplaçant nombre par un nombre) en début de syntaxe pour définir la séquence de nombre. Cette fonction sera utilisée à plusieurs reprises dans le de reproduire les mêmes sorties.","code":"\nset.seed(\"nombre\")"},{"path":"fonctions-statistiques-essentielles.html","id":"les-distributions","chapter":" 3 Fonctions statistiques essentielles","heading":"3.8 Les distributions","text":"Il existe plusieurs distributions déjà programmées avec R. Voici les principales utilisées dans cet ouvrage.\nTable 3.1: Noms des distributions, fonctions et leurs arguments\nLes libellés ci-dessus ne commanderont pas de fonction. Il faut joindre en préfixe à ces distributions l’une des quatre lettres suivantes : d, p,q, ou r. La plus simple est certainement r (random) qui génère n valeurs aléatoires de la distribution demandée selon les paramètres spécifiés. Les fonctions q (quantile) prend un argument de 0 à 1 (100%), soit un percentile et retourne la valeur de la distribution. La fonction p (probabilité) retourne la probabilité cumulative (du minimum jusqu’à la valeur) d’une valeur de cette distribution. Enfin, la lettre d (densité) permet, notamment, d’obtenir les valeurs de densité de la distribution.Voici un exemple avec la distribution normale.Ces quatre lettres peuvent être associées à toutes les distributions énumérées et bien d’autres. Elles respectent toutes ce cadre.","code":"\nset.seed(9876)\n# Génère 5 nombres aléatoires en fonction des paramètres\nrnorm(n = 5, mean = 10, sd = .5)\n#> [1] 10.5  9.4  9.9 10.0 10.0\n# Retourne les valeurs associés à ces probabilités\nqnorm(c(.025,.975))\n#> [1] -2  2\n# Retourne la probabilité d'obtenir un score de 1.645 et moins\npnorm(1.645)\n#> [1] 0.95\n# La valeur de la densité de la distribution\ndnorm(0)\n#> [1] 0.4"},{"path":"fonctions-statistiques-essentielles.html","id":"création-dune-matrice","chapter":" 3 Fonctions statistiques essentielles","heading":"3.9 Création d’une matrice","text":"Une dernière fonction, la fonction matrix() sera utile pour créer des matrices. La fonction utilise trois arguments, une matrice de nombre à entrer dans la matrice, un nombre de colonnes et un nombre de lignes. La fonction utilise le recyclage, ce qui pourra être utile à certaines occasions.Les matrices sont une formes de jeu données (numérique seulement). Plus tard, les data.frame ou jeu de données seront présentés.","code":"\n# Une matrice de 0\nmatrix(0, ncol = 3, nrow = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    0    0    0\n#> [2,]    0    0    0\n#> [3,]    0    0    0\n# Une matrice contenant les nombres 1:3 pour une matrice 3x3\nmatrix(1:3, ncol = 3, nrow = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    2    2    2\n#> [3,]    3    3    3\n# Si la séquence préféré serait de gauche à droite plutôt\n# de bas en haut\nmatrix(1:3, ncol = 3, nrow = 3, byrow = TRUE)\n#>      [,1] [,2] [,3]\n#> [1,]    1    2    3\n#> [2,]    1    2    3\n#> [3,]    1    2    3\n# Une matrice avec un nombre d'entrées égale au nombre de cellule\nmatrix(1:16, ncol = 4, nrow = 4)\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    5    9   13\n#> [2,]    2    6   10   14\n#> [3,]    3    7   11   15\n#> [4,]    4    8   12   16"},{"path":"exercice-rudiments.html","id":"exercice-rudiments","chapter":"Exercices","heading":"Exercices","text":"Rédiger une fonction calculant la moyenne d’une variable.Rédiger une fonction pour générer une séquence de Fibonacci (chaque nombre est la somme des deux précédents) jusqu’à une certaine valeur, soit \\(1,1,2,3,5,8,...\\).Rédiger une fonction calculant un score-\\(z\\) pour une variable.Rédiger une fonction calculant l’hypoténuse d’un triangle rectangle.Rédiger une fonction qui pivote une liste de \\(k\\) éléments par \\(n\\). Par exemple, une liste de six (\\(k=6\\) comme \\([1,2,3,4,5,6]\\)) pivoté de deux (\\(n=2\\)) devient (\\([3,4,5,6,1,2]\\)).","code":""},{"path":"gestion-de-base-des-jeux-de-données.html","id":"gestion-de-base-des-jeux-de-données","chapter":" 4 Gestion de base des jeux de données","heading":" 4 Gestion de base des jeux de données","text":"Un jeu de données porte généralement les extensions “.Rdata”, lorsqu’elles proviennent de R, ou d’extensions “.dat” et “.txt”. Évidemment, R permet une grande flexibilité, il est ainsi possible d’exporter et d’importer dans d’autres extensions.Les extensions “.Rdata” sont des environnements R, elles contiennent potentiellement plusieurs variables, comme une séance de travail complète. Elles ont aussi l’avantage que, si l’utilisateur double-clique sur un fichier d’extension “.Rdata”, celui-ci s’ouvre automatiquement dans l’environnement R.Il est recommandé de ne jamais manipuler les fichiers de données une fois toutes les vérifications réalisées (absence d’erreur dans les données). Il ne sera jamais nécessaire de modifier ces fichiers avec R. Contrairement aux logiciels traditionnels dans lesquels les modifications sont apportées directement aux valeurs ou ajoutées aux fichiers, cela n’est pas nécessaire dans la mesure où les syntaxes décrivant ces manipulations sont conservées. Il devient impossible d’endommager, de corrompre ou d’altérer le fichier de données. Les données originales restent intactes. Il suffit de les importer puis de commander la syntaxe qui lui est associée.Il est possible de voir les données en utilisant la fonction View() et en y insérant le nom de la variable. Le logiciel afficher un tableur avec les données, dont il sera impossible de modifier les valeurs. Cela peut être utile pour s’assurer que le jeu de données est en ordre.","code":""},{"path":"gestion-de-base-des-jeux-de-données.html","id":"quelques-conseils-de-gestion","chapter":" 4 Gestion de base des jeux de données","heading":"4.1 Quelques conseils de gestion","text":"Voici quelques conseils pour la gestion le jeu de données.Éviter les noms trop longs ou trop courts et dépourvus de signification. Cela augmente le risque d’erreur. L’utilisation de huit caractères ou moins est une bonne recommandation (quoique ce n’est pas une règle!). Pour conserver plus de renseignements, utiliser les commentaires de la syntaxe.Éviter les noms trop longs ou trop courts et dépourvus de signification. Cela augmente le risque d’erreur. L’utilisation de huit caractères ou moins est une bonne recommandation (quoique ce n’est pas une règle!). Pour conserver plus de renseignements, utiliser les commentaires de la syntaxe.Éviter les espaces entre les mots. Cela peut être interprété erronément comme deux éléments. À la place, collez les mots et distinguer-les avec des majuscules (MaFonction), utiliser le tiret bas (ma_fonction) ou un point (ma.fonction).Éviter les espaces entre les mots. Cela peut être interprété erronément comme deux éléments. À la place, collez les mots et distinguer-les avec des majuscules (MaFonction), utiliser le tiret bas (ma_fonction) ou un point (ma.fonction).Éviter les espaces ou les vides dans les données. Cela peut être interprété comme des données (absentes) ou non.Éviter les espaces ou les vides dans les données. Cela peut être interprété comme des données (absentes) ou non.Éviter les symboles suivants ?, $, %, ^, &, *, (, ), -, #, ?, , , <, >, /, |, \\, [, ], { et } qui peuvent erronément être interprétés comme de la syntaxe autant dans les noms de variables que dans les données.Éviter les symboles suivants ?, $, %, ^, &, *, (, ), -, #, ?, , , <, >, /, |, \\, [, ], { et } qui peuvent erronément être interprétés comme de la syntaxe autant dans les noms de variables que dans les données.Vérifier que les valeurs manquantes sont identifiées NA.Vérifier que les valeurs manquantes sont identifiées NA.Si les données proviennent d’un autre logiciel, vérifier la présence de commentaires qui pourraient occasionner des lignes ou colonnes supplémentaires et ainsi corrompre le jeu de données.Si les données proviennent d’un autre logiciel, vérifier la présence de commentaires qui pourraient occasionner des lignes ou colonnes supplémentaires et ainsi corrompre le jeu de données.Vérifier que l’exportation et l’importation se sont bien déroulées.Vérifier que l’exportation et l’importation se sont bien déroulées.","code":""},{"path":"gestion-de-base-des-jeux-de-données.html","id":"sauvegarder-un-jeu-de-données","chapter":" 4 Gestion de base des jeux de données","heading":"4.2 Sauvegarder un jeu de données","text":"Si un jeu de données est directement créé avec R, par exemple, les jeux de données artificiels, il est possible de les sauvegarder avec la fonction save() qui enregistre une variable dans un fichier.Il est possible à la fin d’une session de travail de sauvegarder l’environnement dans un fichier save.image(). Ainsi, toutes les variables et fonctions maison sont conservées pour une future utilisation.","code":"\nsave(\"variable\", file = \"fichier.Rdata\")\nsave.image(file = \"SessionTravail.Rdata\")"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"jeux-de-données-provenant-de-r-et-de-packages","chapter":" 4 Gestion de base des jeux de données","heading":"4.3 Jeux de données provenant de R et de packages","text":"Plusieurs packages offrent en plus des fonctions des jeux de données. Mieux encore! R offre des jeux de données inclus avec le logiciel. La fonction data() permet de voir la liste des jeux de données disponibles. Taper simplement le nom du jeu de données permet de l’utiliser, comme s’il avait été déclaré auparavant.La fonction head() introduite ici donne simplement un aperçu des six premières lignes du jeu de données pour ne pas afficher le jeu de données complet (ce qui prendrait beaucoup d’espace inutilement.Pour consulter tous les jeux de données des packages importés, il est possible d’utiliser cette ligne de code.Pour utiliser ces jeux, il faut rendre actif le package associé avec la fonction library().","code":"\nhead(cars)\n#>   speed dist\n#> 1     4    2\n#> 2     4   10\n#> 3     7    4\n#> 4     7   22\n#> 5     8   16\n#> 6     9   10\ndata(package = .packages((all.available = TRUE)))"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"création-des-jeux-de-données-artificielles","chapter":" 4 Gestion de base des jeux de données","heading":"4.4 Création des jeux de données artificielles","text":"Une façon rudimentaire et efficace d’obtenir des données avec R est de les créer à l’aide des fonctions génératrices de données pseudoaléatoires.Et voilà un jeu de données simple et sauvegardé dans le dossier de travail auquel il sera possible de se référer.Ici, deux nouvelles fonctions sont employées : round() arrondie les valeurs à l’unité et data.frame() crée un le jeu de données. L’utilisation des = permet de directement nommer les variables.","code":"\n# Pour la reproductibilité\nset.seed(142)\n# Nombre d'unité\nn <- 30\n# Identifiant\nid <- 1:n\n\n# Variables\nsexe <- rbinom(n, size = 1, prob = .5)\nQI <-  round(rnorm(30, mean = 100, sd = 15) - 5 * sexe)\n# Être \"1\" soustrait  5 points au QI en moyenne\n# Arrondi avec round()\n\n# Création de le jeu de donnees\ndonnees <-  data.frame(id = id, sexe = sexe, QI = QI)\n# Enregistrement\nsave(donnees, file = \"donnees.Rdata\")"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"jeux-de-données-provenant-de-ibm-spss","chapter":" 4 Gestion de base des jeux de données","heading":"4.4.1 Jeux de données provenant de IBM SPSS","text":"Il est possible d’importer des données de IBM SPSS vers R. il faudra quelques manipulations préalables. En ayant le fichier de données IBM SPSS ouvert, il faut cliquer sur “Enregistrer sous” sous le menu déroulant “Fichier”. Par défaut, IBM SPSS choisira toutes les variables, mais il est possible de sélectionner seulement les variables d’intérêt en décochant les variables qu’il n’est pas nécessaire de conserver. Ensuite, sélectionner le type de fichier de sauvegarde doit être “Tabulé (*.dat)“. IBM SPSS offre également la possibilité d’enregistrer les noms de variables (première option à cocher) et les libellés de valeur. Il suffit maintenant de nommer le fichier et de cliquer sur l’onglet”Enregister”.En s’assurant que nouveau fichier se trouve dans le répertoire actif de R, il suffit de télécharger le fichier.L’option header devrait être FALSE si les noms de variables n’ont pas été conservés (première ligne du fichier) .","code":"\nread.table(file = \"donnees.tab\", header = TRUE)"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"jeux-de-données-provenant-de-microsoft-excel","chapter":" 4 Gestion de base des jeux de données","heading":"4.4.2 Jeux de données provenant de Microsoft Excel","text":"Fichier sous le menu déroulant. Sélectionner comme type de fichier “Texte Unicode (*.txt)“. Intituler le fichier, puis cliquer sur”Enregister”.Microsoft Excel sauvegardera l’entièreté de la page active. Il est donc pertinent de créer une feuille Microsoft Excel contenant que les informations à conserver.Par la suite, en s’assurant que nouveau fichier se trouve dans le répertoire actif de R, il suffit de télécharger le fichier avec read.table() et les arguments convenant au jeu de données.","code":""},{"path":"gestion-de-base-des-jeux-de-données.html","id":"importation-de-jeux-de-données-avec-rstudio.","chapter":" 4 Gestion de base des jeux de données","heading":"4.4.3 Importation de jeux de données avec RStudio.","text":"RStudio offre une interface simple pour télécharger directement un jeu de de données IBM SPSS, Microsoft Excel, SAS, STATA, et des extensions “.txt” et “.readr”. Il y même un outil de visualisation pour s’assurer que le tout est en ordre.FileImport datasetFrom “format de fichier”où “format de fichier” remplace Text, SPSS, Excel et les autres. En indiquant le chemin du fichier, R importera le fichier et fournira une syntaxe afin de conserver l’importation pour de futurs usages.","code":""},{"path":"gestion-de-base-des-jeux-de-données.html","id":"manipulation-de-données","chapter":" 4 Gestion de base des jeux de données","heading":"4.5 Manipulation de données","text":"Les tableaux ont généralement deux dimensions (lignes par colonnes). Différents éléments ou groupes d’éléments peuvent être extraits des jeux de données. Plusieurs méthodes peuvent être utiliser en fonction des besoins. Le jeu de données cars sera utilisé à des fins illustratives.Elle contient 50 unités d’observation (lignes) et deux variables (colonnes), soit la vitesse (speed) et la distance (dist).","code":"\nhead(cars)\n#>   speed dist\n#> 1     4    2\n#> 2     4   10\n#> 3     7    4\n#> 4     7   22\n#> 5     8   16\n#> 6     9   10"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"référer-à-une-variable-dans-un-jeu-de-données","chapter":" 4 Gestion de base des jeux de données","heading":"4.5.1 Référer à une variable dans un jeu de données","text":"Il est possible de référer à une variable soit en utilisant l’emplacement de la variable par rapport aux autres en utilisant les crochets ou en utilisant le signe $ puis le nom de la variable après le libellé de le jeu de données. L’opération est fort simple avec le symbole $.Précédemment utilisés pour extraire des valeurs dans une variable unidimensionnelle, les [] peuvent extraire des données sur un tableau en deux dimensions (ligne par colonne). Il faut spécifier la ou les lignes désirées, puis la ou les colonnes désirées entre crochets. Laissez une des dimensions en blanc (vide) indique au logiciel de rapporter toutes les valeurs. Par exemple, pour obtenir le même résultat, dist est la deuxième colonne. Il faut référer entre crochets à la colonne \\(2\\) et comme toutes les lignes sont désirées, cette dimension reste vide.Il est possible de faire la même chose avec les lignes.Ici, toutes les variables de la 4e unité sont rapportée. Remarquer bien l’absence d’argument après la virgule. La fonction head n’est pas nécessaire ici, car il y peu d’informations à extraire.Si certaines valeurs spécifiques étaient désirées, comme la valeur de la 4e unité pour la 2e variable.Enfin, à l’intérieur d’un jeu de données, les variables peuvent être commandées avec le signe de $ placé après le nom de la variable suivi du nom de la variable ou encore en identifiant les noms de variables entre crochets.","code":"\n# Avec $\nhead(cars$dist)\n#> [1]  2 10  4 22 16 10\n# Entre crochets\nhead(cars[,2])\n#> [1]  2 10  4 22 16 10\n# Entre crochets\ncars[4,]\n#>   speed dist\n#> 4     7   22\n# Entre crochets\ncars[4, 2]\n#> [1] 22\n# Utilisation du signe $\nhead(cars$speed)\n#> [1] 4 4 7 7 8 9\n\n# Nommer entre crochets\nhead(cars[\"speed\"])\n#>   speed\n#> 1     4\n#> 2     4\n#> 3     7\n#> 4     7\n#> 5     8\n#> 6     9"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"référer-à-un-sous-ensemble-dunité.","chapter":" 4 Gestion de base des jeux de données","heading":"4.5.2 Référer à un sous-ensemble d’unité.","text":"Pour référer à des unités ayant certaines caractéristiques, la fonction subset() peut s’avérer utile. Les arguments sont un jeu de données, le deuxième est un opérateur logique en lien avec une variable du jeu de données.Cette fonction est utile s’il faut extraire les données d’un certain sexe, par exemple.","code":"\n# Extraire les données pour toutes les unités ayant une vitesse égale à 24\nsubset(cars, speed == 24)\n#>    speed dist\n#> 46    24   70\n#> 47    24   92\n#> 48    24   93\n#> 49    24  120"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"nommer-des-variables-dans-un-jeu-de-données","chapter":" 4 Gestion de base des jeux de données","heading":"4.5.2.1 Nommer des variables dans un jeu de données","text":"Il est possible d’attribuer ou de modifier des noms à des colonnes ou des lignes d’un tableau de données. Les fonctions colnames() et rownames() seront alors utilisées. Contrairement aux autres fonctions, celles-ci se retrouvent à gauche de l’équation.Il importe de fournir autant de noms qu’il y de colonnes (ou lignes), et ce, en chaîne de caractères.","code":"\ncolnames(cars) <-  c(\"vitesse\", \"distance\")\nhead(cars)\n#>   vitesse distance\n#> 1       4        2\n#> 2       4       10\n#> 3       7        4\n#> 4       7       22\n#> 5       8       16\n#> 6       9       10"},{"path":"gestion-de-base-des-jeux-de-données.html","id":"données-manquantes","chapter":" 4 Gestion de base des jeux de données","heading":"4.5.3 Données manquantes","text":"Les devis de recherche et les jeux de données empiriques sont rarement parfaits et peuvent souvent contenir des données manquantes. R reconnaît les données manquantes lorsqu’elles sont identifiées comme NA (available). Plusieurs méthodes permettent de gérer les données manquantes. La méthode la plus simple est d’éliminer les unités ayant une donnée manquante, soit la suppression par liste (listwise suppression). Les fonctions natives de R recourront à l’argument na.rm = TRUE. Si cela est impossible, la fonction na.omit() permettra de créer des jeux de données sans les valeurs manquantes.","code":"\nvaleurs <-  c(10, 12, 14, NA, 18)\n# La présence de NA empêche la moyenne d'être calculée\nmean(valeurs)\n#> [1] NA\n# L'argument \"na.rm = TRUE\" gère les NA\nmean(valeurs, na.rm = TRUE)\n#> [1] 14\n# na.omit omet les valeurs NA dans la nouvelle variable.\nvaleurs.nettoyees <-  na.omit(valeurs)\nmean(valeurs.nettoyees)\n#> [1] 14"},{"path":"entrée-de-données.html","id":"entrée-de-données","chapter":" 5 Entrée de données","heading":" 5 Entrée de données","text":"S’il y bien une caractéristique de R qui rebute les nouveaux utilisateurs, c’est certainement que le logiciel ne soit pas prévu pour la saisie de données ou du moins que cela ne soit pas mis à l’avant-plan. Lorsque le logiciel s’ouvre, que ce soit R ou RStudio, l’aspect table de données n’existe pas. L’utilisateur pour qui il s’agit de sa première utilisation (et habitué à des logiciels traditionnels) reste pantois : où les données sont-elles entrées?","code":""},{"path":"entrée-de-données.html","id":"entrée-de-données-avec-data.entry-r-de-base","chapter":" 5 Entrée de données","heading":"5.1 Entrée de données avec data.entry() (R de base)","text":"De base, R offre la possibilité d’entrer des données dans un tableur avec la commande jd = data.entry(). Si une base de données est demandée comme argument (p. ex., data.entry(data = jd)), alors le jeu de données est ouvert. Il est aussi possible d’ouvrir le fichier avec des variables déjà créées avec R. Si un tableur vierge est désiré, alors taper data.entry(1) dans la console ouvrira le tableur avec une seule valeur (1), L’utilisateur peut alors modifier les noms de colonnes et entrer les données comme il le ferait avec un logiciel traditionnel. Comme il est possible de le voir à la Figure 5.1, l’interface est bien moins attrayante que ses compétiteurs.\nFigure 5.1: Ouverture du tableur R\nLorsque l’entrée de données est terminée, l’utilisateur doit sauvegarder le jeu de données ou l’environnement de travail qui pourront être importés pour de futures utilisations ou entrées. En général, l’utilisateur qui entre manuellement ces données préférera certainement un autre tableur, mais R est certainement en mesure de faire ce travail.","code":""},{"path":"entrée-de-données.html","id":"entrée-de-données-avec-data_edit-package-dataeditr","chapter":" 5 Entrée de données","heading":"5.2 Entrée de données avec data_edit (package DataEditR)","text":"Depuis tout récemment (juillet 2021), il existe un package qui permet de faire l’entrée de données en tableur avec R. Il s’agit du package DataEditR (Hammill, 2021), une interface utilisateur graphique. Il résout l’un de plus grands défis lorsqu’un utilisateur migre des tableurs traditionnels vers R, c’est-à-dire d’accomplir la transition d’une feuille de calcul interactive où il est possible de pointer et cliquer pour modifier, ajouter, supprimer des donnes vers un mode strict de syntaxe.Pour démarrer, il faut d’abord installer le package, puis l’appeler. Pour commencer à entrer des données, la syntaxe data_edit() est suffisante. Pour ouvrir un jeu de données, il suffit de l’ajouter en argument data_edit(jd).Il est recommandé de ne laisser que les données brutes, toutes les modifications et manipulations devraient rester en syntaxe R dans un script associé au jeu de données. Lorsque les entrées sont terminées, il faut simplement sauvegarder la base de données, préférablement en extension .csv. Il est aussi possible de sortir le tableur en tableau de données en assignant la fonction à une variable comme jd = data_edit().\nFigure 5.2: Ouverture du tableur de DataEditR\nEn général, l’utilisateur importera ces données dans l’environnement R. Il devra même le faire avec data_edit() à chaque ouverture d’un nouvelle séance, pour poursuivre l’entrée ou réaliser des manipulations.","code":"\ninstall.packages(\"DataEditR\")\nlibrary(\"DataEditR\")\ndata_edit()"},{"path":"importation-de-jeux-de-données.html","id":"importation-de-jeux-de-données","chapter":" 6 Importation de jeux de données","heading":" 6 Importation de jeux de données","text":"Dans la plupart des situations, les analyses et les graphiques seront réalisés à partir d’un jeu de données se trouvant dans un fichier. Ce devra être importé en R pour être manipulé. Les jeux de données peuvent se trouver dans un fichier dans l’ordinateur, mais aussi sur le web. Ils peuvent être en différents types de format.Dans le premier chapitre, une méthode est présentée pour importer des données. Lorsqu’il provenait d’un logiciel comme IBM SPSS ou Excel, l’accent était mis sur l’exportation de ces données dans un certain format, puis l’importation avec R. Il n’est pas toujours nécessaire d’exporter ces données, puisque le logiciel à l’aide des fonctions de base ou de packages peut lire des fichiers d’une multitude d’extensions.Pour la description de l’importation, l’ouvrage tient pour acquis que le fichier de données se retrouve dans le directoire de travail (ce qui est l’idéal en général). Un peu plus loin, la création de trajectoires pour différents emplacements sera présentée.Les fonctions de base permettront d’importer la plupart des jeux de données, particulièrement s’ils ont été exportés dans un format compatible. Pour le cas où ces fichiers ne pourraient être exportés de cette façon, des packages pallieront ce besoin. Dans cet ouvrage, seule une présentation sommaire de ces options sera discutée, l’utilisateur est recommandé à la documentation de ces packages pour plus d’informations.La prochaine section décrit les fonctions pour importer les bases de données “manuellement”. En plus de ces méthodes, RStudio possède une interface permettant l’importation des données.","code":""},{"path":"importation-de-jeux-de-données.html","id":"la-fonction-de-base","chapter":" 6 Importation de jeux de données","heading":"6.1 La fonction de base","text":"La fonction de base read.table() permettra d’importer la plupart des jeux de données. C’est d’ailleurs ce qui été présenté sommairement dans le chapitre sur les rudiments. Parfois, ceux-ci ont certaines caractéristiques qu’il faudra préciser comme argument à la fonction read.table() pour assurer une importation adéquate. Ces caractéristiques sont header = FALSE, sep = \"\", et fill = !blank.lines.skip (les éléments à droite sont les options par défaut).Parfois, certains fichiers sauvegardent le nom des variables en tête de colonne (première ligne). Par défaut, R assume qu’il s’agit de valeurs. L’argument header = TRUE ajouté à read.table() précisera à R lors de l’important que ces libellés sont des noms de colonnes.Si un autre symbole est utilisé pour délimiter (séparer) des valeurs dans le fichier, comme ;ou ,, l’argument sep = \";\" ou sep = \",\" précisera le séparateur.Si les lignes du fichier sont de tailles inégales, R assumera qu’il s’agit de valeur, et ces blancs de texte seront ajoutés comme valeurs (\"\"). Pour gérer cette situation, l’argument fill = FALSE devrait régler la situation.","code":""},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.txt","chapter":" 6 Importation de jeux de données","heading":"6.2 Fichiers d’extension .txt","text":"Un fichier d’extension .txt ou un fichier texte délimité par des tabulations (tab-delimited text files) est importé à l’aide de la fonction read.table().","code":"\njd = read.table(\"fichier.txt\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.csv","chapter":" 6 Importation de jeux de données","heading":"6.3 Fichiers d’extension .csv","text":"Un fichier d’extension .csv use généralement de séparateur comme \";\" (lorsque le système numérique de la langue d’origine utilise la virgule - comme le français par exemple) ou \",\" (pour les autres langues qui n’utilise pas la virgule) et ont généralement les noms de variables en première ligne. Ainsi, la fonction read.table() est utilisable pourvu que le séparateur soit précisé et la présence d’en-tête également.Il existe aussi la fonction read.csv() et read.csv2() pour importer des fichiers d’extension .csv. Il s’agit exactement de read.table() à l’exception des arguments par défaut, mais précisant par défaut header = TRUE et fill = TRUE et détecte s’il s’agit de \";\" ou \",\".","code":"\njd = read.table(\"fichier.csv\", sep = \";\", header = TRUE)"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-délimités","chapter":" 6 Importation de jeux de données","heading":"6.4 Fichiers délimités","text":"Pour les fichiers recourant à un autre caractère qu’une tabulation, qu’une \",\", ou un \";\" pour délimiter les valeurs, spécifier le caractère dans read.table() importera le fichier.Comme pour read.csv() et read.csv2(), les fonctions read.delim() et read.delim() pourraient être utilisées.","code":"\njd = read.table(\"fichier.txt\", sep = \"$\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.sav-.dta-.syd-et-.mtp","chapter":" 6 Importation de jeux de données","heading":"6.5 Fichiers d’extension .sav, .dta, .syd et .mtp","text":"Comme le lecteur s’en doute peut-être, R de base ne permet pas d’importer des fichiers spécifiques d’autres logiciels. Par contre, avec les années se sont développés des packages permettant de pallier la situation. Le package foreign permet d’importer des fichiers issus de IBM SPSS (.sav), Stata (.dta) et Systat (.syd) et Minitab (mtp) avec, respectivement les fonctions read.spss(), read.data(), read.systat() et read.mtp(). La logique d’importation est la même pour ces quatre fonctions.Pour read.spss(), deux arguments sont importants à souligner. Par défaut, la fonctionne ne retourne pas un data frame et utilise les libellés de valeurs (value labels). Dans la plupart des cas, l’utilisateur désire probablement obtenir un jeu de données de type data.frame et les valeurs sous-jacentes au libellés de valeurs. L’utilisateur peut alors changer ces arguments .data.frame = TRUE (par défaut FALSE) et use.value.labels = FALSE(par défaut TRUE).Consulter la documentation du package pour plus d’informations sur les options possibles.","code":"\nlibrary(foreign)\n\n# SPSS\njd = read.spss(\"fichier.sav\",to.data.frame = TRUE,use.value.labels = FALSE)\n\n# Stata\njd = read.dta(\"fichier.dta\")\n\n# Systat\njd = read.systat(\"fichier.syd\") \n\n# Minitab\njd = read.mtp(\"fichier.mtp\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.xls-et-xlsx","chapter":" 6 Importation de jeux de données","heading":"6.6 Fichiers d’extension .xls et xlsx","text":"Il n’existe pas de fonction de base pour importer des fichiers Microsoft Excel (extensions .xls et .xlsx). Par contre, il existe plusieurs packages qui permettront de la faire, comme readxl. Le package readlxl permet d’utiliser la fonction read_excel() pour importer le fichier.La fonction read_excel() possède un argument sheet = qui permet de préciser la feuille qu’il faut importer ou range = (p. ex. range = A1:B20 qui permet d’importer un rectangle de plage de données (du coin supérieur gauche A1 au coin inférieur droit B20).\nConsulter la documentation du package pour plus d’informations sur les options possibles.","code":"\n#Excel\nlibrary(readxl)\njd = read_excel(\"fichier.xls\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.html","chapter":" 6 Importation de jeux de données","heading":"6.7 Fichiers d’extension .html","text":"Il n’existe pas de fonction de base pour importer des fichiers d’extension .html, (HTML, HyperText Markup Language). Le package XML fournit une solution possible avec la fonction readHMTLTable().Consulter la documentation du package pour plus d’informations sur les options possibles.","code":"\n#HTML\nlibrary(XML)\njd = readHMTLTable(\"fichier.html\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.json","chapter":" 6 Importation de jeux de données","heading":"6.8 Fichiers d’extension .json","text":"Il n’existe pas de fonction de base pour importer des fichiers d’extension .json, (JavaScript Object Notation). Comme le lecteur pourra s’y attendre, il existe un package pour rectifier la situation : le package rjson et sa fonction fromJSON().Consulter la documentation du package pour plus d’informations sur les options possibles.","code":"\n#JSON\nlibrary(rjson)\njd = fromJSON(\"fichier.json\")"},{"path":"importation-de-jeux-de-données.html","id":"fichiers-dextension-.sas7bdat","chapter":" 6 Importation de jeux de données","heading":"6.9 Fichiers d’extension .sas7bdat","text":"Il n’existe pas de fonction de base pour importer des fichiers d’extension .sas7bdat, (Statistical Analysis System). Il existe le package sas7bdat pour importer des données de SAS vers R avec la fonction read.sas7bdat().Consulter la documentation du package pour plus d’informations sur les options possibles.","code":"\n# SAS\nlibrary(sas7bdat)\njd = read.sas7bdat(\"fichier.sas7dbat\")"},{"path":"importation-de-jeux-de-données.html","id":"emplacement-du-jeu-de-données","chapter":" 6 Importation de jeux de données","heading":"6.10 Emplacement du jeu de données","text":"Idéalement, le fichier contenant le jeu de données sera déjà dans le directoire de travail (ou dan le projet R en cours). Dans ce contexte, référer seulement au nom du fichier suffira.Si le jeu de données est sur le web, il peut être importé en précisant l’URL.S’il est plutôt dans un fichier sur l’ordinateur, mais pas dans le directoire de travail, ce sera essentiellement la même méthode.Si l’utilisateur ne connaît pas exactement la trajectoire, il peut se résoudre à passer par l’explorateur de fichiers (Windows ou Apple) pour déterminer l’emplacement du fichier de jeu de données. Il faut alors utiliser la fonction file.choose() sans aucun argument à l’intérieur de la fonction d’importation.L’utilisateur devra alors identifier manuellement (pointer et cliquer) où se trouve le fichier. Il devra se promener de fichier en fichier jusqu’à ce qu’il arrive au bon jeu de données, un peu comme le font les logiciels traditionnels lorsque l’utilisateur souhaite sauvegarder un fichier à un certain endroit.","code":"\njd = read.table(\"fichier.txt\")\njd = read.table(\"https://site/ou/trouver/le/fichier.txt\")\njd = read.table(\"C:/site/ou/trouver/le/fichier.txt\")\njd = read.table(file.choose())"},{"path":"importation-de-jeux-de-données.html","id":"conseils-dimportation","chapter":" 6 Importation de jeux de données","heading":"6.11 Conseils d’importation","text":"Parfois des valeurs s’ajoutent lors de l’exportation ou l’importation des données. Des logiciels traditionnels font parfois ce mauvais tour. Une vérification de la base de données est par conséquent impérative, surtout lors de la première utilisation du jeu de données. Deux méthodes de vérification sont suggérées. D’abord ouvrir le fichier avec un éditeur de texte de base, comme bloc-notes, pour s’assurer qu’aucun caractère ne s’est indésirable ajouté à l’insu de l’utilisateur. Ensuite, voir avec la fonction View() dans R si la base de données s’affiche correctement et que les variables, et lignes semblent correspondre à ce qui est attendu.","code":""},{"path":"importation-de-jeux-de-données.html","id":"gestion-avancée-de-jeux-de-données","chapter":" 6 Importation de jeux de données","heading":"6.12 Gestion avancée de jeux de données","text":"Avec R, il ne sera jamais nécessaire de manipuler directement le fichier contenant les données. Cette pratique est déconseillée. Préserver le fichier original intact évite de nombreuses complications, comme la compatibilité entre les versions, la reproductibilité des bases, la maintenance, etc. Toutes les manipulations seront conservées dans un script. Cela favorise le partage entre collègues, mais aussi le suivi des modifications apportées en comparant tout simplement les traces dans entre les syntaxes. Le jeu de données est importé dans la console et il ne sera plus touché par l’utilisateur. Le script consevera les manipulations réalisées qui pourront être refaites facilement en quelques cliques.En pratique, l’expérimentateur aura le jeu de données officielles (final) avec lequel travailler. Il pourra l’importer tel que précisé dans la section précédente. Par la suite, il ne lui reste qu’à mettre en place le nettoyage et la préparation du jeu de données. Il existe plusieurs méthodes pour réalise la gestion; il ne faut pas s’étonner de voir d’autres ouvrages aborder la gestion de données d’une autre façon. Au final, la meilleure méthode est celle qui m’est l’utilisateur à son aise. Le présent ouvrage tente de monter une approche intuitive et simple, mais il ne faut pas en faire un dogme.","code":""},{"path":"importation-de-jeux-de-données.html","id":"le-tidyverse","chapter":" 6 Importation de jeux de données","heading":"6.13 Le tidyverse","text":"Le nom tidyverse (Wickham et al., 2019) est une contraction de tidy (bien rangé) et de universe. Le package est fondé sur le concept de tidy data, développé par Hadley (Wickham, 2014). Il repose sur une philosophie d’organisation des données facilitant la gestion, la préparation et le nettoyage préalable aux analyses quantitatives. Plusieurs packages respectent cette philosophie et font partie intégrante du tidyverse, comme ggplot2 (présentation graphique), dplyr (manipulation de données), readr (importation de données), tibble (nouvelle catégorie de data frame), mais bien d’autres également. Ces packages font part intégrante de l’univers tidy et sont téléchargés simultanément avec le package.Pour utiliser le package tidyverse, il faudra d’abord l’installer puis l’appeler.","code":"\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)"},{"path":"importation-de-jeux-de-données.html","id":"les-fonctions-utiles","chapter":" 6 Importation de jeux de données","heading":"6.14 Les fonctions utiles","text":"Un des avantages et nouveautés d’utiliser le tidyverse est d’obtenir l’opérateur %>% (appelée pipe en anglais que l’pourrait traduire par tuyau) qui provient originellement du package magrittr (Bache & Wickham, 2020) et est importé par dplyr. L’opérateur favorise la lisibilité et la productivité, car il est plus facile de suivre le flux de plusieurs fonctions à travers ces tuyaux que de revenir en arrière lorsque plusieurs fonctions sont imbriquées. En fait, il favorise la lecture par verbes, soit par action (fonction), dans une séquence temporelle intuitive. Si les arguments sont placés en une seule ligne, non seulement la ligne est-elle longue et complexe, voire illisible, mais, en plus, les éléments les plus à gauche (les premiers à la lecture) sont les derniers opérés. Si chacune des fonctions était en ligne, alors il faudrait écraser ou créer des variables temporaires inutiles tout simplement pour arriver à réaliser les fonctions. La philosophie tidyverse, par l’usage de %>%, évite tous ses problèmes.L’opérateur %>% s’ajoute à la fin d’une ligne syntaxe. Son fonctionnement se traduit par l’argument de la ligne à gauche est introduit dans la fonction de droite. Il peut être commandé plus rapidement avec le raccourci CTRL + Shift + M sur Windows. En plus de l’opérateur %>% , dplyr offre de nouvelles fonctions pour gérer une base de données. Quelques-unes des plus importantes sont décrites ici. Par la suite, une mise en contexte permettra de mieux comprendre leur fonctionnement.","code":""},{"path":"importation-de-jeux-de-données.html","id":"sélectionner-des-variables","chapter":" 6 Importation de jeux de données","heading":"6.14.1 Sélectionner des variables","text":"Pour sélectionner des données d’un très grand jeu de données, la fonction select() permettra de choisir les variables à conserver. Pour utiliser la fonction, il suffit d’indiquer les variables par leur nom de colonne dans la fonction.","code":""},{"path":"importation-de-jeux-de-données.html","id":"sélectionner-des-participants","chapter":" 6 Importation de jeux de données","heading":"6.14.2 Sélectionner des participants","text":"Pour filtrer les participants selon les caractéristiques désirées, la fonction filter() permettra de sélectionner les unités satisfaisant les conditions spécifiées. Pour utiliser la fonction, il faut indiquer le ou les arguments conditionnels à respecter et sur quelle variable.Dans ce contexte la fonction na.() peut être utile pour retirer une valeur aberrante.","code":""},{"path":"importation-de-jeux-de-données.html","id":"transformer-et-créer-des-variables","chapter":" 6 Importation de jeux de données","heading":"6.14.3 Transformer et créer des variables","text":"Pour créer ou transformer des variables, la fonction mutate() permettra de créer de nouvelles variables à partir des valeurs déjà dans le jeu de données. Il suffit d’indiquer dans la fonction, le calcul qui doit être opérer.","code":""},{"path":"importation-de-jeux-de-données.html","id":"sommariser-les-informations-pertinentes","chapter":" 6 Importation de jeux de données","heading":"6.14.4 Sommariser les informations pertinentes","text":"Pour obtenir des informations sur le jeu de données ainsi créées, la fonction summarise() permettra notamment d’obtenir des statistiques d’intérêt. En ajoutant, dans la fonction, les fonctions désirées, comme mean() ou sd(), avec les variables sur lesquelles elles devraient être opérées ou encore n() pour connaître la taille des groupes.S’il y des groupes ou des catégories, le sommaire peut être divisé avec la fonction group_by() où la variable nominale est spécifiée.","code":""},{"path":"importation-de-jeux-de-données.html","id":"autres-fonctions","chapter":" 6 Importation de jeux de données","heading":"6.14.5 Autres fonctions","text":"Il existe plusieurs autres fonctions possibles. Notamment, slice() permet de choisir les unités désirées en passant comme argument la base de données et le ou les numéros de ligne; sample_slice() qui est très similaire, retourne des lignes aléatoires; rename(), similaire à select(), permet de renommer les variables; arrange reclasse par ordre croissant en fonction d’une variable placée en argument. Et il y en plusieurs autres.","code":""},{"path":"importation-de-jeux-de-données.html","id":"mise-en-pratique","chapter":" 6 Importation de jeux de données","heading":"6.15 Mise en pratique","text":"Pour mettre en pratique la philosophie tidyverse, voici un exemple tiré du jeu de données starwars. Ce jeu de données possède de nombreuses caractéristiques (diversité de variables, de mesures, données manquantes) qui en font un jeu de données similaires à ce qu’un expérimentateur pourrait obtenir. Le jeu de données est déjà disponible avec R.Sans plus de préliminaire, la fonction head() donne un aperçu du jeu de donnéesPour obtenir de l’information sur ce jeu de données.Voici la description du jeu de données (traduction libre),Les données d’origine, issues de SWAPI, l’API de Star Wars, https://swapi.dev/, ont été révisées pour tenir compte des recherches supplémentaires sur la détermination du genre et du sexe des personnages.Peu utile comme descripteur, une inspection des données est plus informative. Pour afficher le jeu de données dans un nouvel onglet.Le fichier contient, le nom de 87 personnages mesurés sur 14 variables, soitle nom;le nom;la taille (cm);la taille (cm);le poids (kg);le poids (kg);la couleur des cheveux, de la peau et des yeux (trois variables);la couleur des cheveux, de la peau et des yeux (trois variables);l’année de naissance;l’année de naissance;le sexe biologique (mâle, femelle, hermaphrodite ou aucun);le sexe biologique (mâle, femelle, hermaphrodite ou aucun);le genre;le genre;la planète natale;la planète natale;l’espèce;l’espèce;une liste de films où le personnage apparaît;une liste de films où le personnage apparaît;une liste des véhicules que le personnage piloté;une liste des véhicules que le personnage piloté;une liste des vaisseaux que le personnage piloté.une liste des vaisseaux que le personnage piloté.L’objectif est de cette mise en situation est de comparer les hommes et les femmes humaines par rapport à leur indice de masse corporelle (IMC) ou body mass index (BMI). Le calcul de l’IMC consiste à diviser le poids par la taille au carré (kg/m2).Les étapes à considérer sont les suivantes : sélectionner les variables pertinentes, filtrer en retirant les unités d’espèces non humaines, tenir compte des données manquantes, corriger la taille des unités qui devrait être en mètre et non en centimètre (divisé par 100) et créer l’indice de masse corporelle.Les étapes de la syntaxe se lisent comme suit :La première ligne starwars %>% indique l’objet sur lequel il faut passer les fonctions subséquentes;La première ligne starwars %>% indique l’objet sur lequel il faut passer les fonctions subséquentes;puis, select(sex, mass, height, species) %>% indique les variables à conserver pour les fonctions subséquentes;puis, select(sex, mass, height, species) %>% indique les variables à conserver pour les fonctions subséquentes;puis, filter(species == \"Human\") filtre les unités qui sont humains et passe aux fonctions subséquentes;puis, filter(species == \"Human\") filtre les unités qui sont humains et passe aux fonctions subséquentes;puis, na.omit() %>% retire les valeurs manquantes des unités dans le jeu de données et passe aux fonctions subséquentes;puis, na.omit() %>% retire les valeurs manquantes des unités dans le jeu de données et passe aux fonctions subséquentes;puis, mutate(height = height  / 100) %>%, transforme la variable height et passe à la dernière fonction;puis, mutate(height = height  / 100) %>%, transforme la variable height et passe à la dernière fonction;enfin, mutate(IMC = mass / height^2) crée la variable d’IMC.enfin, mutate(IMC = mass / height^2) crée la variable d’IMC.Si une méthode plus traditionnelle avait été utilisée, la syntaxe pourrait ressembler à ceci.Le jeu de données est créé en autant de ligne de syntaxe. Par contre, la lecture n’est pas aussi intuitive qu’avec l’utilisation de l’opérateur %>% et des fonctions associées select(), filter(), mutate(). Il ne faut pas trop penser à quoi ressemblerait ces manipulations en une seule ligne de syntaxe.Une fois le jeu de données prêt, il est possible d’obtenir les informations sommaires. Ici, la moyenne, l’écart type, la valeur minimale et maximale ainsi que le nombre de données sont demandés en fonction du sexe. À cette étape, l’avantage d’embrasser la philosophie tidyverse apparaît, en quelques lignes rudimentaires, les cinq statistiques demandées sont affichées, et ce, par groupes.La base de données issues de ces opérations pourra par la suite être utilisée normalement pour réaliser des analyses statistiques. Il existe des packages pour demeurer dans le tidyverse comme rstatix.","code":"\nhead(starwars[,1:6])\n#> # A tibble: 6 x 6\n#>   name          height  mass hair_color skin_color eye_color\n#>   <chr>          <int> <dbl> <chr>      <chr>      <chr>    \n#> 1 Luke Skywalk~    172    77 blond      fair       blue     \n#> 2 C-3PO            167    75 <NA>       gold       yellow   \n#> 3 R2-D2             96    32 <NA>       white, bl~ red      \n#> 4 Darth Vader      202   136 none       white      yellow   \n#> 5 Leia Organa      150    49 brown      light      brown    \n#> 6 Owen Lars        178   120 brown, gr~ light      blue\n?starwars\nView(starwars)\n# Importer le tidyverse avant de commencer\nlibrary(tidyverse)\n\njd = starwars %>% \n  select(sex, mass, height, species) %>% \n  filter(species == \"Human\") %>% \n  na.omit() %>% \n  mutate(height = height  / 100) %>% \n  mutate(IMC = mass / height^2)  \njd\n#> # A tibble: 22 x 5\n#>    sex     mass height species   IMC\n#>    <chr>  <dbl>  <dbl> <chr>   <dbl>\n#>  1 male      77   1.72 Human    26.0\n#>  2 male     136   2.02 Human    33.3\n#>  3 female    49   1.5  Human    21.8\n#>  4 male     120   1.78 Human    37.9\n#>  5 female    75   1.65 Human    27.5\n#>  6 male      84   1.83 Human    25.1\n#>  7 male      77   1.82 Human    23.2\n#>  8 male      84   1.88 Human    23.8\n#>  9 male      80   1.8  Human    24.7\n#> 10 male      77   1.7  Human    26.6\n#> # ... with 12 more rows\njd = starwars[, c(\"sex\", \"mass\", \"height\", \"species\")]  # select()\njd = jd[jd[, \"species\"] == \"Human\",]                    # filter()\njd = na.omit(jd)                                        # na.omit()\njd[,\"height\"] = jd[,\"height\"] / 100                     # mutate()\njd[,\"IMC\"] = jd[,\"mass\"] / jd[,\"height\"]^2              # mutate()\njd\n#> # A tibble: 22 x 5\n#>    sex     mass height species   IMC\n#>    <chr>  <dbl>  <dbl> <chr>   <dbl>\n#>  1 male      77   1.72 Human    26.0\n#>  2 male     136   2.02 Human    33.3\n#>  3 female    49   1.5  Human    21.8\n#>  4 male     120   1.78 Human    37.9\n#>  5 female    75   1.65 Human    27.5\n#>  6 male      84   1.83 Human    25.1\n#>  7 male      77   1.82 Human    23.2\n#>  8 male      84   1.88 Human    23.8\n#>  9 male      80   1.8  Human    24.7\n#> 10 male      77   1.7  Human    26.6\n#> # ... with 12 more rows\njd %>% \n  group_by(sex) %>% \n  summarise(mean(IMC), sd(IMC), min(IMC), max(IMC), length(IMC)) \n#> # A tibble: 2 x 6\n#>   sex    `mean(IMC)` `sd(IMC)` `min(IMC)` `max(IMC)`\n#>   <chr>        <dbl>     <dbl>      <dbl>      <dbl>\n#> 1 female        22.0      5.51       16.5       27.5\n#> 2 male          26.0      4.29       21.5       37.9\n#> # ... with 1 more variable: `length(IMC)` <int>\nlibrary(rstatix)\n# Test-t sur l'IMC en fonction du sexe\njd %>% \n  t_test(IMC ~ sex)\n#> # A tibble: 1 x 8\n#>   .y.   group1 group2    n1    n2 statistic    df     p\n#> * <chr> <chr>  <chr>  <int> <int>     <dbl> <dbl> <dbl>\n#> 1 IMC   female male       3    19     -1.23  2.40 0.326\n\n# Analyse de corrélations\njd %>% \n  select(IMC, mass, height) %>% \n  cor_test() \n#> # A tibble: 9 x 8\n#>   var1   var2     cor statistic         p conf.low conf.high\n#>   <chr>  <chr>  <dbl>     <dbl>     <dbl>    <dbl>     <dbl>\n#> 1 IMC    IMC     1      2.12e+8 5.26e-155    1.00      1    \n#> 2 IMC    mass    0.85   7.32e+0 4.47e-  7    0.674     0.938\n#> 3 IMC    height  0.18   8.13e-1 4.26e-  1   -0.262     0.558\n#> 4 mass   IMC     0.85   7.32e+0 4.47e-  7    0.674     0.938\n#> 5 mass   mass    1      3.00e+8 5.13e-158    1         1    \n#> 6 mass   height  0.65   3.84e+0 1.02e-  3    0.317     0.842\n#> 7 height IMC     0.18   8.13e-1 4.26e-  1   -0.262     0.558\n#> 8 height mass    0.65   3.84e+0 1.02e-  3    0.317     0.842\n#> 9 height height  1    Inf       0            1         1    \n#> # ... with 1 more variable: method <chr>"},{"path":"visualisation-des-données.html","id":"visualisation-des-données","chapter":" 7 Visualisation des données","heading":" 7 Visualisation des données","text":"La visualisation de données est l’un des deux objectifs fondamentaux de R (l’autre étant évidemment de faire des statistiques). Il existe plusieurs méthodes et packages pour produire rapidement et simplement des graphiques. Beaucoup de matériel se retrouve en ligne pour maîtriser les graphiques, mais surtout les personnaliser. L’objectif, bien modeste, de cette section n’est pas de rendre le lecteur maître de la production de figure, mais bien de lui faire faire ses premiers pas et de l’outiller pour qu’il puisse produire simplement et rapidement des graphiques de qualité.","code":""},{"path":"visualisation-des-données.html","id":"ggplot2","chapter":" 7 Visualisation des données","heading":"7.1 ggplot2","text":"Le package ggplot2 est une extension du tidyverse avec lequel il est possible de créer simplement et rapidement des graphiques. Ces graphiques sont de qualité de publications, idéale pour les articles scientifiques. Le package fournit un langage graphique pour la création intuitive de graphiques compliqués. Il permet à l’utilisateur de créer des graphiques qui représentent des données numériques et catégorielles univariées et multivariées.La logique de ggplot2 repose sur la grammaire des graphiques (Grammar Graphics), c’est-à-dire, l’idée selon laquelle toutes les figures peuvent être construites à partir des mêmes composantes. Il s’agit de la deuxième version du package. Voilà pour l’appellation ggplot2.Dans la grammaire de graphique, une figure possède huit niveaux, dont les trois principaux sont les suivants :data, les données utilisées;data, les données utilisées;mapping (aesthetic), cartographier les variables, c’est-à-dire, établir la carte des variables (abscisses, ordonnées, coleur, forme, taille, etc.);mapping (aesthetic), cartographier les variables, c’est-à-dire, établir la carte des variables (abscisses, ordonnées, coleur, forme, taille, etc.);geometric représentation, la représentation géométrique ou le type de représentation graphique, par exemple, diagramme de dispersion, histogramme, boîte à moustache, etc.geometric représentation, la représentation géométrique ou le type de représentation graphique, par exemple, diagramme de dispersion, histogramme, boîte à moustache, etc.Les cinq autres son, statistics, facet, coordinate space, labels, theme permettent de personnaliser la figure.Les composantes les plus importantes sont les trois premières, soit les données, la cartographie et la représentation géométrique. Ce sont les éléments de base pour débuter le graphique. Les autres composantes viendront bonifier la figure tout en l’ajustant au besoin de l’utilisateur.La fonction ggplot() met en place la figure. Le résultat d’utiliser la fonction ggplot() seule est illustrée à la Figure 7.1\nFigure 7.1: La fonction ggplot() seule - Rien\nIl est aussi possible de piper (prononcé avec un fort accent anglophone) les données dans la fonction.Pour afficher des graphiques, il faut ajouter +, puis une représentation géométrique ainsi que la cartographie (mapping). La cartographie (aes(mapping = )- aes désigne l’esthétisme, aesthetic) peut se trouver dans ggplot() ou dans la représentation géométrique. Si elle est dans ggplot, elle est passée aux autres niveaux.Voici une liste des représentations géométriques possibles.geom_line() crée une ligne qui lie toutes les valeurs, très utiles pour une série temporelle (abscisse = temps, ordonnée = variable dépendante)geom_line() crée une ligne qui lie toutes les valeurs, très utiles pour une série temporelle (abscisse = temps, ordonnée = variable dépendante)geom_point() crée un diagramme de dispersion ou un nuage de point, très utile pour les corrélationsgeom_point() crée un diagramme de dispersion ou un nuage de point, très utile pour les corrélationsgeom_bar() crée un diagramme à bâton, idéal pour présenter des proportions, des fréquences ou des données comptéesgeom_bar() crée un diagramme à bâton, idéal pour présenter des proportions, des fréquences ou des données comptéesgeom_histogram() crée un histogramme des variablesgeom_histogram() crée un histogramme des variablesgeom_box() crée une boîte à moustache, idéal pour identifier des valeurs aberrantes et comparer la variabilité entre des groupes.geom_box() crée une boîte à moustache, idéal pour identifier des valeurs aberrantes et comparer la variabilité entre des groupes.geom_smooth() crée la ligne de prédiction des données avec des intervalles de confiances, la plupart des utilisateurs voudront certainement ces arguments geom_smooth(method = lm) (par défaut) ou sans l’erreur standard (se = FALSE).geom_smooth() crée la ligne de prédiction des données avec des intervalles de confiances, la plupart des utilisateurs voudront certainement ces arguments geom_smooth(method = lm) (par défaut) ou sans l’erreur standard (se = FALSE).geom_error() crée degeom_error() crée deCertaines cartographies sont d’ailleurs compatibles, geom_smooth() et geom_point(), par exemple.La figure 7.2 montre un diagramme dispersion construit à partir du jeu de données jd piper dans la fonction ggplot() dans laquelle la cartographie est passée mapping = aes(x = mass, y = height), un second niveau est ajouté + et la représentation.\nFigure 7.2: Diagramme de dispersion\nVoici une liste d’exemples de différentes représentations géométriques.","code":"\nggplot(data = jd)\njd %>% \n  ggplot()\njd %>% \n  ggplot(mapping = aes(x = mass, y = height)) + \n  geom_point()"},{"path":"visualisation-des-données.html","id":"diagramme-de-dispersion","chapter":" 7 Visualisation des données","heading":"7.2 Diagramme de dispersion","text":"Pour réaliser un diagramme de dispersion, la fonction se nomme geom_point. La cartographie identifie la variable à l’axe des \\(x\\) (horizontal) et des \\(y\\) (vertical). Dans cet exemple, il s’agit du poids (\\(x\\)) et de la taille (\\(y\\)). La cartographie ne se limite pas aux axes par contre. Dans cet exemple, la forme shape est aussi un dimension manipulée. Il aurait pu s’agir de color et même de size. Dans le code ci-dessous, size est placé à l’extérieur de mapping, il s’agit alors d’une constante (elle change la taille des points), c’est-à-dire qu’elle ne varie pas avec les variables.\nFigure 7.3: Le lien entre le poids et la taille en fonction du sexe\nLa figure 7.4 montre le résultat si `size``est ajouté au mapping pour identifier l’IMC. Les unités avec un plus grand IMC obtiennent un plus gros pointeur.\nFigure 7.4: Le lien entre le poids et la taille en fonction de l’IMC et du sexe\npeut y ajouter la droite de régression, comme la Figure 7.5 le montre. Ne pas ajouter geom_point() ne ferait que produire la droite. Les arguments de geom_smooth() indique que l’utilisation du modèle linéaire et l’absence des intervalles de confiance. Dans ce code, également comme le mapping est ajouté à ggplot directement, il se généralise directement à geom_point() et geom_smoooth()\nFigure 7.5: Le lien entre le poids et la taille en fonction de l’IMC\n","code":"\njd %>% \n  ggplot() + \n  geom_point(mapping = aes(x = mass, y = height, shape = sex), size = 2) \njd %>% \n  ggplot() + \n  geom_point(mapping = aes(x = mass, y = height, shape = sex, size = IMC)) \njd %>% \n  ggplot(mapping = aes(x = mass, y = height)) + \n  geom_point(size = 2) +\n  geom_smooth(method = lm, se = FALSE, color = \"black\")\n#> `geom_smooth()` using formula 'y ~ x'"},{"path":"visualisation-des-données.html","id":"boîte-à-moustache","chapter":" 7 Visualisation des données","heading":"7.3 Boîte à moustache","text":"La boîte à moustaches (box--whisker plot) est une figure permettant de voir la variabilité des données. Elle résume seulement quelques indicateurs de position soit la médiane, les quartiles, le minimum, et le maximum. Ce diagramme est utilisé principalement pour détecter des valeurs aberrantes et comparer la variabilité entre les groupes. C’est la représentation géométrique geom_boxplot() qui permettra de créer des boîtes à moustache. La cartographie prend en argument un variable nominale en x et une variable continue en y.\nFigure 7.6: Boîte à moustache de l’IMC en fonction du sexe\nUne fonction intéressante est la fonction coord_flip() qui tourne (flip) les axes, les coordonnées. Elle peut être pratique pour améliorer la qualité visuelle de certains graphiques.","code":"\nggplot(data = jd) + \n  geom_boxplot(mapping = aes(x = sex, y = IMC)) +\n  coord_flip()"},{"path":"visualisation-des-données.html","id":"histogramme","chapter":" 7 Visualisation des données","heading":"7.4 Histogramme","text":"Un histogramme permet de représenter la répartition empirique d’une variable. Il donne aperçu de la distribution sous-jacente, soit comment les données sont distribuées. Cette figure permet de voir la forme de la distribution et permet de voir si elle ne démontre pas d’anomalie. La représentation graphique geom_histogram() produit des histogrammes. S’il faut en produire pour différentes variables, une statégie simple est les produire en série.Des techniques plus avancées permettront de créer la Figure 7.7 d’un seul coup.\nFigure 7.7: Histogrammes des variables continues\nEnfin, s’il est désiré de comparer deux distributions de groupes différents, l’argument fill dans la cartographie indiquera à la fonction de différencier les valeurs selon le remplissage des histogrammes.\nFigure 7.8: Histogrammes de l’IMC par rapport au sexe\nDans la figure 7.8, l’argument position = \"identity\" indique de traiter les deux groupes comme différents, autrement les colonnes s’additionneraient dans le graphique. L’argument alpha = .7 permet une transparence entre les couleurs, autrement, les valeurs derrière les autres ne paraîtraient pas. La valeur de alpha va de 0 (transparent) à 1 (opaque) et fonctionnera dans la plupart des contextes, surtout ceux liés à ggplot2.","code":"\n# Trois histogrammes en trois figures\nggplot(data = jd) + \n  geom_histogram(mapping = aes(x = height))\n\nggplot(data = jd) + \n  geom_histogram(mapping = aes(x = mass))\n\nggplot(data = jd) + \n  geom_histogram(mapping = aes(x = IMC))\n# Trois histogrammes en une seule figure\n# en optimisant avec le tidyverse\njd %>%\n  keep(is.numeric) %>% \n  gather() %>% \n  ggplot(aes(value)) +\n  facet_wrap(~ key, scales = \"free\") +\n  geom_histogram()\n#> `stat_bin()` using `bins = 30`. Pick better value with\n#> `binwidth`.\njd %>% \n  ggplot(mapping = aes(x = IMC, fill = sex)) + \n  geom_histogram(position = \"identity\", alpha = .7) + \n  scale_fill_grey()\n#> `stat_bin()` using `bins = 30`. Pick better value with\n#> `binwidth`."},{"path":"visualisation-des-données.html","id":"les-barres-derreurs","chapter":" 7 Visualisation des données","heading":"7.5 Les barres d’erreurs","text":"Les barres d’erreur sont une représentation géométrique à part entière. C’est une composante que l’peut ajouter. La fonction pour les commandées est geom_errorbar(). Elle nécessite deux arguments, soit l’intervalle de confiance maximale et minimale autour des moyennes à afficher.La figure 7.9 illustre les différences entre moyennes avec des barres d’erreur à partir de la base de données ToothGrowth, une étude de l’effet de la vitamine C (dose) selon leur administration (jus ou supplément supp) sur la longueur des dents des cochons d’inde. Il y deux facteurs et une variable continue.La première étape est de tirer les statistiques sommaires, moyennes, écart type, tailles des groupes. ici, la syntaxe tire profit de groupe_by() pour tirer les groupes et en faire le sommaire. Le sommaire summarise permet d’obtenir les statistiques, notamment la moyenne, l’erreur standard (se) pour en calculer l’intervalle autour la moyenne ci.\nFigure 7.9: Les effets de la vitamine C sur les cochons d’inde\nUne fois ces statistiques calculées et enregistrées dans le nouveau jeu de données jd, il est possible de créer le graphique avec les représentations géométriques désirées. Remarquer comment spécifié la cartographie dans le niveau ggplot() rend la syntaxe moins compliquée. Cette syntaxe produit un graphique avec dose comme axe des x, supp comme pointeurs et les moyennes de len (longueur moyenne des dents). La fonction geom_errorbar() indique où placer les limites inférieures et supérieures des intervalles. Les arguments size = 5 et width = .05 sont ajoutés par pur esthétisme. L’argument .groups = \"drop\" de summarise permet d’éviter une avertissement expliquant qu’une variable de groupement est utilisé pour regrouper les résultats à la fin. Ajouter ou retirer cet argument ne change pas les calculs.","code":"\njd = ToothGrowth %>% \n  group_by(dose, supp) %>% \n  summarise(mlen = mean(len),\n            sdlen = sd(len),\n            nlen = n(), \n            se = sd(len)/sqrt(n()), \n            ci = qt(.975, df = n()-1) * se,\n            .groups = \"drop\")\n\njd %>% \n  ggplot(aes(x = dose,\n             y = mlen, \n             shape = supp),\n         size = 5) + \n    geom_errorbar(aes(ymin = mlen - ci,\n                      ymax = mlen + ci), \n                  width = .05) +\n    geom_line() +\n    geom_point()"},{"path":"visualisation-des-données.html","id":"pour-aller-plus-loin","chapter":" 7 Visualisation des données","heading":"7.6 Pour aller plus loin","text":"Il existe une multitudes de livres, de sites web, de tutoriels en ligne et d’atelier pour donner l’occasion au lecteur d’aller plus loin dans sa conception graphique. Voici quelques ouvrages de références : Le R Graphics Cookbook (Chang) repérable à https://r-graphics.org/, ggplot2: elegant graphics data analysis (Wickham) repérable à https://ggplot2-book.org/ ou R Graphics (Murrel) repérable à https://www.stat.auckland.ac.nz/~paul/RG2e/.","code":""},{"path":"exercice-gestion.html","id":"exercice-gestion","chapter":"Exercices","heading":"Exercices","text":"Prendre le jeu de données mtcars et produire un diagramme de dispersion montrant la puissance brute (en chevaux) (hp) par rapport à consommation en km/l (basé sur mpg) tout en soulignant l’effet du nombre de cylindres (cyl). Attention la fonction as_factor permettra d’utiliser cyl en facteur.Prendre le jeu de données mtcars et produire un diagramme de dispersion montrant la puissance brute (en chevaux) (hp) par rapport à consommation en km/l (basé sur mpg) tout en soulignant l’effet du nombre de cylindres (cyl). Attention la fonction as_factor permettra d’utiliser cyl en facteur.Prendre le jeu de données mtcars et produire un histogramme montrant la variabilité de la consommation mpg par rapport à la transmission (). Attention la fonction as_factor permettra d’utiliser en facteur.Prendre le jeu de données mtcars et produire un histogramme montrant la variabilité de la consommation mpg par rapport à la transmission (). Attention la fonction as_factor permettra d’utiliser en facteur.Prendre le jeu de données msleep et produire un diagramme à bâton pour observer la fréquence de différents type de régime (vore). Attention aux données manquantes.Prendre le jeu de données msleep et produire un diagramme à bâton pour observer la fréquence de différents type de régime (vore). Attention aux données manquantes.Prendre le jeu de données msleep et produire une boîte à moustache pour observer le temps total de sommeil (sleep_total) par rapport aux régimes (vore). Attention aux données manquantes.Prendre le jeu de données msleep et produire une boîte à moustache pour observer le temps total de sommeil (sleep_total) par rapport aux régimes (vore). Attention aux données manquantes.","code":""},{"path":"références.html","id":"références","chapter":"Références","heading":"Références","text":"","code":""}]
