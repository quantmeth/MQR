<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title> 1 L’analyse en composantes principales | Méthodes Quantitatives avec R</title>
<meta name="author" content="P.-O. Caron">
<meta name="description" content="L’analyse en composantes principales (ACP) est une technique de réorganisation de la variance d’un jeu de données. Son objectif est ainsi de résumer l’information commune des variables dans les...">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content=" 1 L’analyse en composantes principales | Méthodes Quantitatives avec R">
<meta property="og:type" content="book">
<meta property="og:url" content="mqr.teluq.ca/lanalyse-en-composantes-principales.html">
<meta property="og:description" content="L’analyse en composantes principales (ACP) est une technique de réorganisation de la variance d’un jeu de données. Son objectif est ainsi de résumer l’information commune des variables dans les...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content=" 1 L’analyse en composantes principales | Méthodes Quantitatives avec R">
<meta name="twitter:description" content="L’analyse en composantes principales (ACP) est une technique de réorganisation de la variance d’un jeu de données. Son objectif est ainsi de résumer l’information commune des variables dans les...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script>
</head>
<body>
<p>
    \(
    \newcommand{\EX}{\mathbb{E}}
    \)
    <script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="bs4_style.css"></p>

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Méthodes Quantitatives avec R</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bienvenue!</a></li>
<li><a class="" href="pr%C3%A9face.html">Préface</a></li>
<li><a class="active" href="lanalyse-en-composantes-principales.html"><span class="header-section-number">1</span> L’analyse en composantes principales</a></li>
<li><a class="" href="solutions.html">Solutions</a></li>
<li><a class="" href="r%C3%A9f%C3%A9rences.html">Références</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/quantmeth/MQR">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="lanalyse-en-composantes-principales" class="section level1" number="1">
<h1>
<span class="header-section-number"> 1</span> L’analyse en composantes principales<a class="anchor" aria-label="anchor" href="#lanalyse-en-composantes-principales"><i class="fas fa-link"></i></a>
</h1>
<p>L’analyse en composantes principales (ACP) est une technique de réorganisation de la variance d’un jeu de données. Son <em>objectif</em> est ainsi de résumer l’information commune des variables dans les premières dimensions et l’information individuelle dans les dernières. Le statisticien profite alors de cette analyse pour tenir compte des données le mieux possible avec le moins de composantes (ou dimensions, axes ou facteurs latents). Une composante est grossièrement de la variance partagée entre des variables. Conceptuellement, il s’agit de la recette de fabrication des scores de la population, ou d’où origine ces variables (avec quoi elles sont construites). Cela sera détaillé plus en profondeur dans une prochaine section.</p>
<p>Voici un exemple assez commum où l’ACP sera utile. Lorsqu’un test psychométrique est créé, le psychométricien s’intéresse à connaître quels items (variables) sont liés sur quelle dimension et à quel degré. Les items communs devraient alors être lié sur un certain facteur et pas ou peu sur les autres, ce qui fera que le facteur à un fort potentiel explicatif (ou pas!). L’ACP a une optique d’utilisation beaucoup plus grande que l’analyse factorielle exploratoire. L’expérimentateur pourrait s’intéresser à seulement réorganiser la variance sans aucune visée <em>factorielle</em>. Il pourrait vouloir identifier l’ensemble des meilleurs prédicteurs ou encore résumer l’information de façon à générer des figures qui seraient autrement trop complexes. Enfin, l’ACP peut aussi être conceptualisé comme une forme de compression comme en informatique. Puisque l’information se trouve dans les premières composantes, les moins informatives peuvent être discartées afin de résumer un maximum d’informations sur les données avec le minimum de facteurs.</p>
<p>L’ACP maximise l’information commune aux variables dans les premières composantes jusqu’à l’information individuelle dans les dernières, ce qu’un statisticien qualifierait de variance résiduelle. Elle le fait peu importe la structure factorielle sous-jacente. Conséquemment, l’ACP ne dit sous aucune condition le nombre de composantes <em>signifiantes</em> (importantes) dans le jeu de données. S’il y a <span class="math inline">\(k\)</span> variables, elle résume la variance en <span class="math inline">\(k\)</span> dimensions. Cependant, le statisticien opportuniste sait que l’information pertinente se trouve dans les premiers axes et peut l’utiliser pour résumer les données. Il a ainsi recourt à des <em>règles d’arrêt</em> (<em>stopping rules</em>) pour inférer le nombre de dimensions à retenir. De plus, l’ACP ne restreint pas les loadings à certaines valeurs (notamment 0, soit l’absence de lien entre un facteur et un variable), ce qui est fait dans les <strong>analyses factorielles confirmatoires</strong>. Ces deux caractéristiques, soit l’absence du nombre de facteurs et de restrictions sur les poids factoriels (loadings, qui seront détaillés plus tard), font de l’ACP une <strong>analyses factorielles exploratoires</strong>. Autrement dit, le statisticien n’impose pas un certain modèle sur les données, il laisse les données parler.</p>
<div id="une-analogie-cuisinaire" class="section level2" number="1.1">
<h2>
<span class="header-section-number">1.1</span> Une analogie cuisinaire<a class="anchor" aria-label="anchor" href="#une-analogie-cuisinaire"><i class="fas fa-link"></i></a>
</h2>
<p>Cette analogie revient à André Achim qui n’a de cesse parler d’analyse factorielle en termes de <em>recette</em> de fabrication<a href="r%C3%A9f%C3%A9rences.html#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Il n’a jamais poussé l’audace jusqu’à parler de cuisine, mais le temps est venu.</p>
<p>Cet exemple est basé sur les recettes de fabrication de biscuits (voir Figure <a href="lanalyse-en-composantes-principales.html#fig:biscuit">1.1</a>)<a href="r%C3%A9f%C3%A9rences.html#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. Réaliser une analyse factorielle avec des biscuits permettra d’identifier le biscuit prototypique, le plus biscuits des biscuits : le biscuit fondamental, celui sur lequel tous les biscuits sont basés.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:biscuit"></span>
<img src="14-ACP_files/figure-html/biscuit-1.png" alt="Biscuits significativement chocolatés" width="60%" height="60%"><p class="caption">
Figure 1.1: Biscuits significativement chocolatés
</p>
</div>
<p>Pour ce faire, l’expérimentateur recrute des biscuits qui représentent les unités (participants)<a href="r%C3%A9f%C3%A9rences.html#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. Comme tout bon scientifique, il prend maintenant des mesures sur ces biscuits : taux de sucre, taux de gluten, quantité de fruit, de chocolat, de cacao, taux de protéines de sel, bref un peut tout ce que l’étiquette nutritive offre comme information. Ces mesures sont les variables. Ces variables sont toutes intercorrélées en quelques sortes: un biscuit ayant une concentration plus forte en chocolat et en fruits séchés peut se permettre d’être moins de sucré artificiellement; un autre plus riche en protéine et pauvre en gluten sera peut-être plus gras pour le rendre plus intéressant en bouche; les biscuits de type sec seront peut-être plus salé à cause des gras moins présents.</p>
<p>Une fois ces mesures prises, l’analyse en composantes principales réorganise la variance afin de mettre les composantes les plus importantes comme premières. En étudiant la structure factorielle, il sera possible de définir qualitativement les axes obtenus. Par exemple, le premier axe pourrait être lié aux variables de sucres (chocolat, fruit, sucre, cassonade, sucre de canne, etc) et tout ce qui peut apporter directement ou indirectement au glucose, signalant du même coup, l’importance du sucre dans les recettes de biscuits. Le deuxième axe pourrait être basé sur les gras (crème, huile, beurre, lait), signalant l’importance qu’un bon biscuit est non seulement sucré (dimension 1), mais gras (dimension 2). Les dimensions se détaillent ainsi de suite jusqu’à ce qu’il ne reste que du bruit, des idiosyncrasies parmi les recettes de biscuit (comme des graines de tournesol!). L’expérimentateur trouve alors dans ces informations, les axes qui font ce qu’est être un biscuit.</p>
<!-- Les lecteurs seront intéressés de savoir que des études similaires ont réellement eu lieu pour étudier les saveurs du whisky, etc... Dans ces études, ce n'est pas tant la recette que l'appréciation gustative des connaisseurs. Par la suite, on pourrait en tirer des pastilles de goût en voyant comment les saveurs s'agencent ensemble^[Ce n'est pas ce qui a été fait à la Société des Alcools du Québec, mais ce serait une façon scientifique d'entreprendre la démarche]. -->
</div>
<div id="quelques-définitions" class="section level2" number="1.2">
<h2>
<span class="header-section-number">1.2</span> Quelques définitions<a class="anchor" aria-label="anchor" href="#quelques-d%C3%A9finitions"><i class="fas fa-link"></i></a>
</h2>
<div id="les-valeurs-propres" class="section level3" number="1.2.1">
<h3>
<span class="header-section-number">1.2.1</span> Les valeurs propres<a class="anchor" aria-label="anchor" href="#les-valeurs-propres"><i class="fas fa-link"></i></a>
</h3>
<p>Les valeurs propres (<em>eigenvalues</em>) représentent l’aspect crucial de l’ACP, soit l’importance de chaque composante à représenter les variables. Plus un facteur agit en force sur variables en force, mais aussi sur le nombre de variables, plus la valeur propre sera élevée; plus la dimension sera extraite dans les premières.</p>
<p>La somme des valeurs propres égale la somme des variances, ce qui équivaut en matrice de corrélation à <span class="math inline">\(p\)</span> le nombre de variables. Comme il s’agit du potentiel maximale de ce qui peut être expliquée et que les valeurs sont une part de ce total, il est possible d’en tirer des pourcentage. Par exemple une valeur propre de 5 sur un total de <span class="math inline">\(p=10\)</span> variables signifie que l’axe correspondant explique <span class="math inline">\(5/10 \times 100 = 50\)</span>% de la variance dans les données.</p>
<p>En d’autres termes, la valeur propre est une bonne métrique de l’importance d’une dimension.</p>
</div>
<div id="les-loadings" class="section level3" number="1.2.2">
<h3>
<span class="header-section-number">1.2.2</span> Les loadings<a class="anchor" aria-label="anchor" href="#les-loadings"><i class="fas fa-link"></i></a>
</h3>
<p>Les loadings (traduits par chargements - il n’y a pas vraiment de bon termes en français) sont les contributions des facteurs aux variables. En termes de recette de fabrication, il s’agit du <em>poids</em> de chaque <em>ingrédients</em> (facteurs) à la <em>recette</em> de la population. Lorsque les variables sont standardisées, (la variance est de <span class="math inline">\(1\)</span>), un loading représente la corrélation entre un facteur et une variable.</p>
</div>
<div id="les-communalités" class="section level3" number="1.2.3">
<h3>
<span class="header-section-number">1.2.3</span> Les communalités<a class="anchor" aria-label="anchor" href="#les-communalit%C3%A9s"><i class="fas fa-link"></i></a>
</h3>
<p>Les communalités correspondent au carré des loadings standardisés. Il s’agit du pourcentage (ou la proportion d’ingrédient, si l’analogie est maintenu avec l’idée de recette de fabrication) d’informations données par le facteur à une variable.</p>
</div>
</div>
<div id="création-de-données" class="section level2" number="1.3">
<h2>
<span class="header-section-number">1.3</span> Création de données<a class="anchor" aria-label="anchor" href="#cr%C3%A9ation-de-donn%C3%A9es"><i class="fas fa-link"></i></a>
</h2>
<p>Pour construire une un jeu de données ayant une structure factorielle, il faut d’abord concevoir cette structure. Il s’agit des recettes de fabrications des variables : beaucoup de facteur 1 pour la variable 3, un peu du facteur 1 sur la variable 2, etc. Chaque composante, dont il y a un nombre de <span class="math inline">\(k\)</span>, s’exprime sur toutes les <span class="math inline">\(p\)</span> variables. Il s’agit en quelques sorte de la quantité de facteur qu’il faut attribuer à telle et telle variable. Ainsi, une matrice <span class="math inline">\(k \times p\)</span> agira comme recette de fabrication pour les variables. Par exemple, s’il y a <span class="math inline">\(2\)</span> facteurs et <span class="math inline">\(6\)</span> variables, les dimensions de la matrice de fabrication est <span class="math inline">\(2 \times 6\)</span>. Cette matrice de fabrication, appelée <span class="math inline">\(\Phi\)</span> (phi, équivalent à “F”) contient les loadings, la quantité de facteur qu’il faut donner aux variables. Les lettres grecques sont préférées ici, car il s’agit de paramètres de la population.</p>
<p>Il est plus simple de considérer pour l’instant une structure standardisée, c’est-à-dire que les variables produites auront des variances de 1 (les moyennes sont écartés, car elles ne sont pas nécessaire, mais pour être plus explicite elles sont nulles). Lors de la spécification de la structure factorielle, il faudra s’assurer que la somme des carrés des loadings de chaque variable ne dépasse pas <span class="math inline">\(1\)</span>, soit la variance désirée des variables. Ne pas respecter cette limite ne créera pas forcément une erreur ou un problème. Seulement, le scénario ne sera plus standardisé.</p>
<p>La Figure <a href="lanalyse-en-composantes-principales.html#fig:FactStruct">1.2</a> illustre un exemple de modèle. Les rectangles sont des variables manifestes (observées) à partir des quelles les variables encerclées représentent des facteurs sous-jacents, soit des variables latentes (retrouvées à partir des variables manifestes.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:FactStruct"></span>
<img src="image/factstruct.png" alt="Structure Factorielle" width="50%" height="50%"><p class="caption">
Figure 1.2: Structure Factorielle
</p>
</div>
<p>La syntaxe ci-dessous reconstruit le modèle de la Figure <a href="lanalyse-en-composantes-principales.html#fig:FactStruct">1.2</a>. La variable <code>phi</code> pour <span class="math inline">\(\Phi\)</span> contient les loadings des deux composantes pour créer les six variables.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Création de la matrice de recette de fabrication</span>
<span class="va">phi</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">.9</span>, <span class="fl">.8</span>, <span class="fl">.7</span>,  <span class="fl">0</span>,  <span class="fl">0</span>, <span class="fl">.4</span>,
               <span class="fl">0</span>,  <span class="fl">0</span>,  <span class="fl">0</span>, <span class="fl">.6</span>, <span class="fl">.5</span>, <span class="fl">.4</span><span class="op">)</span>, <span class="fl">6</span>, <span class="fl">2</span><span class="op">)</span>

<span class="co"># Identification des variables et facteurs</span>
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">phi</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"F1"</span>, <span class="st">"F2"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">phi</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="st">"i"</span>,<span class="fl">6</span><span class="op">)</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span>
<span class="va">phi</span>
<span class="co">#&gt;     F1  F2</span>
<span class="co">#&gt; i1 0.9 0.0</span>
<span class="co">#&gt; i2 0.8 0.0</span>
<span class="co">#&gt; i3 0.7 0.0</span>
<span class="co">#&gt; i4 0.0 0.6</span>
<span class="co">#&gt; i5 0.0 0.5</span>
<span class="co">#&gt; i6 0.4 0.4</span></code></pre></div>
<p>Pour obtenir les communalités de la population, il suffit de mettre <span class="math inline">\(\Phi\)</span> au carré.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">phi</span><span class="op">^</span><span class="fl">2</span>
<span class="co">#&gt;      F1   F2</span>
<span class="co">#&gt; i1 0.81 0.00</span>
<span class="co">#&gt; i2 0.64 0.00</span>
<span class="co">#&gt; i3 0.49 0.00</span>
<span class="co">#&gt; i4 0.00 0.36</span>
<span class="co">#&gt; i5 0.00 0.25</span>
<span class="co">#&gt; i6 0.16 0.16</span></code></pre></div>
<p>Voici quelques description de <span class="math inline">\(\Phi\)</span> sans toute les nommer. Pour les recettes, le variable 1 est construite à 81% du facteur 1 et 0% du second facteur, c’est-à-dire que la variable 1 est construite uniquement du facteur 1. Le facteur 2 donne 25% à la cinquième variable. Enfin, la sixième variable est construite à partir de de 16% du premier facteur et 16% du deuxième facteur pour être construite à 32 % des deux facteurs, il reste ainsi 68% à expliquer qui proviendra de la variance d’erreur de la variable.</p>
<p><span class="math display" id="eq:com">\[\begin{equation}
C = \sum_{i=1}^k \Phi_i^2
\tag{1.1}
\end{equation}\]</span></p>
<p>En équivalent de syntaxe <strong>R</strong>, l’équation <a href="lanalyse-en-composantes-principales.html#eq:com">(1.1)</a> s’écrit comme suit.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">C</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span><span class="op">(</span><span class="va">phi</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span>
<span class="va">C</span>
<span class="co">#&gt;   i1   i2   i3   i4   i5   i6 </span>
<span class="co">#&gt; 0.81 0.64 0.49 0.36 0.25 0.32</span></code></pre></div>
<p>Il s’agit de la variance totale de la variable <span class="math inline">\(i\)</span> expliquée par les facteurs, soit <span class="math inline">\(C_i\)</span>. Il manque maintenant l’erreur, c’est-à-dire, l’information contenu dans les variables qui n’est pas expliquées par un facteur. Cette erreur doit être indépendante des facteurs, mais aussi des variables entre elles, sinon il s’agirait d’un autre facteur. Pour en connaître le volume, <span class="math inline">\(C\)</span> est soustrait de <span class="math inline">\(1\)</span> (la variance désirée des variables) pour obtenir un vecteur de variance résiduelle <span class="math inline">\(\epsilon\)</span>, soit mathématiquement</p>
<p><span class="math display" id="eq:vres">\[\begin{equation}
\sigma^2_{\epsilon} = 1-C
\tag{1.2}
\end{equation}\]</span></p>
<p>ou en code <strong>R</strong>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Variances résiduelles des variables (non expliquées par les facteurs)</span>
<span class="va">e</span> <span class="op">=</span> <span class="fl">1</span><span class="op">-</span><span class="va">C</span>
<span class="va">e</span>
<span class="co">#&gt;   i1   i2   i3   i4   i5   i6 </span>
<span class="co">#&gt; 0.19 0.36 0.51 0.64 0.75 0.68</span></code></pre></div>
<p>Et pour transformer en loading, il faut revenir à l’ordre de grandeur original, en coefficient de corrélation plutôt qu’en coefficient de détermination (en écart type plutôt qu’en variance).</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">e</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span>
<span class="va">e</span>
<span class="co">#&gt;    i1    i2    i3    i4    i5    i6 </span>
<span class="co">#&gt; 0.436 0.600 0.714 0.800 0.866 0.825</span></code></pre></div>
<p>Maintenant il faut joindre, les résidus à la structure factorielle en s’assurant qu’ils demeurent indépendant. Si <code>e</code> est ajouté directement à phi, cela créerait un troisième facteur <em>d’erreur</em> imprévus. Chaque loading d’erreur doit se retrouver sur une dimension indépendante. La stratégie est ainsi de transformer le vecteur <code>e</code> en matrice diagonale avec la fonction <code><a href="https://rdrr.io/r/base/diag.html">diag()</a></code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Joint erroné</span>
<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">phi</span>,<span class="va">e</span><span class="op">)</span>
<span class="co">#&gt;     F1  F2     e</span>
<span class="co">#&gt; i1 0.9 0.0 0.436</span>
<span class="co">#&gt; i2 0.8 0.0 0.600</span>
<span class="co">#&gt; i3 0.7 0.0 0.714</span>
<span class="co">#&gt; i4 0.0 0.6 0.800</span>
<span class="co">#&gt; i5 0.0 0.5 0.866</span>
<span class="co">#&gt; i6 0.4 0.4 0.825</span>

<span class="co"># Joint correct</span>
<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">phi</span>, <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;     F1  F2                                </span>
<span class="co">#&gt; i1 0.9 0.0 0.436 0.0 0.000 0.0 0.000 0.000</span>
<span class="co">#&gt; i2 0.8 0.0 0.000 0.6 0.000 0.0 0.000 0.000</span>
<span class="co">#&gt; i3 0.7 0.0 0.000 0.0 0.714 0.0 0.000 0.000</span>
<span class="co">#&gt; i4 0.0 0.6 0.000 0.0 0.000 0.8 0.000 0.000</span>
<span class="co">#&gt; i5 0.0 0.5 0.000 0.0 0.000 0.0 0.866 0.000</span>
<span class="co">#&gt; i6 0.4 0.4 0.000 0.0 0.000 0.0 0.000 0.825</span>

<span class="co"># La structure factorielle </span>
<span class="va">Struct.Fact</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">phi</span>, <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>Dans le premier cas, <code>e</code> est ajouté comme troisième dimension, ainsi les variables sont corrélés par ce troisième facteur. Dans le second cas, six dimensions sont créés et aucune n’est liée aux autres. L’information partagée demeure dans les facteurs, l’information résiduelle dans les dimensions d’erreur. La structure factorielle <code>Struc.Fact</code> est maintenant <span class="math inline">\(p \times (k + p)\)</span>.</p>
<p>À partir de <code>Struct.Fact</code>, il est possible d’obtenir la matrice de corrélation de la population <span class="math inline">\(\text{P}\)</span> (<span class="math inline">\(\rho majuscule\)</span>) par l’équation <a href="lanalyse-en-composantes-principales.html#eq:fact2cor">(1.3)</a></p>
<p><span class="math display" id="eq:fact2cor">\[\begin{equation}
\text{P} = \Phi \Phi^{\prime}
\tag{1.3}
\end{equation}\]</span></p>
<p>ou en code <strong>R</strong>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">R</span> <span class="op">=</span> <span class="va">Struct.Fact</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">Struct.Fact</span><span class="op">)</span>
<span class="va">R</span>
<span class="co">#&gt;      i1   i2   i3   i4  i5   i6</span>
<span class="co">#&gt; i1 1.00 0.72 0.63 0.00 0.0 0.36</span>
<span class="co">#&gt; i2 0.72 1.00 0.56 0.00 0.0 0.32</span>
<span class="co">#&gt; i3 0.63 0.56 1.00 0.00 0.0 0.28</span>
<span class="co">#&gt; i4 0.00 0.00 0.00 1.00 0.3 0.24</span>
<span class="co">#&gt; i5 0.00 0.00 0.00 0.30 1.0 0.20</span>
<span class="co">#&gt; i6 0.36 0.32 0.28 0.24 0.2 1.00</span></code></pre></div>
<p>Avec <code>R</code> calculée, il est évidemment possible, comme il a été fait précédemment de recourir à la fonction <code><a href="https://rdrr.io/pkg/MASS/man/mvrnorm.html">MASS::mvrnorm()</a></code> avec comme argument <code>Sigma = R</code> pour la matrice de corrélation afin de créer <code>n</code> participants. Cela serait toutefois contreproductif, puisque la fonction <code>mvrnorm()</code> utilise l’ACP pour extraire une structure factorielle pour générer les données. La suite de cette section décriera une autre façon de créer de données, soit celle utilisée sous <code><a href="https://rdrr.io/pkg/MASS/man/mvrnorm.html">MASS::mvrnorm()</a></code>.</p>
<p>Une fois la structure factorielle obtenue, il faut générer les scores des participants. Plusieurs méthodes sont possibles, mais la façon la plus <em>normale</em> sera de prendre un distribution gaussienne. Cette matrice contiendra des scores tirés de cette distribution et sera de taille <span class="math inline">\((k + p) \times n\)</span>, soit le nombre de facteur plus le nombre de variables (pour les résidu) en ligne par <span class="math inline">\(n\)</span> le nombre d’unités en colonnes. Cette matrice représente les scores propres à chaque unité pour chacun des scores et seront multipliés avec la recette factorielle. Autrement dit, chaque poids de la recette (loadings) sera multiplié à une distribution normale qui représente le score du participant pour ce poids. Certains seront plus influencés par un poids et en auront plus, d’autres en auront moins. Et ainsi de suite pour chaque poids.
Comme cela a été vue dans le chapitre sur la loi de la somme de variance, le loading joue le rôle une constante d’échelle qui modifie l’écart type de la distribution. La taille de l’écart type des résidus est par la suite ajustée pour assurer une variance égale à 1, ce qui est fait à l’équation <a href="lanalyse-en-composantes-principales.html#eq:vres">(1.2)</a>. Il est également possible de concevoir selon ce cadre, que chaque facteur est en fait une variable indépendante prédisant la variable ou l’item (variable dépendante).</p>
<p><span class="math display" id="eq:factlm">\[\begin{equation}
y_i = \delta_{1,i} x_1+ \delta_{2,i} x_2 + ... + \delta_{k,i} x_k + \epsilon_{i}
\tag{1.4}
\end{equation}\]</span></p>
<p>Dans l’équation <a href="lanalyse-en-composantes-principales.html#eq:factlm">(1.4)</a>, l’indice <span class="math inline">\(i\)</span> représente l’une des <span class="math inline">\(p\)</span> variables, <span class="math inline">\(\delta_{j,i}\)</span> correspond au loading de la variable <span class="math inline">\(i\)</span> du facteur <span class="math inline">\(j\)</span> (allant de <span class="math inline">\(1,2,...,k\)</span>) et <span class="math inline">\(\epsilon_i\)</span> est l’erreur associé à la variable <span class="math inline">\(i\)</span>. La variable dépendante <span class="math inline">\(y_i\)</span> correspond la variable résultante, ce résultat est observable. Les scores <span class="math inline">\(x_j\)</span> sont <em>latents</em>, ils ne peuvent être observés par l’expérimentateur, seulement inférés par le statisticien. Les <span class="math inline">\(k\)</span> facteurs agissent dans l’équation <a href="lanalyse-en-composantes-principales.html#eq:factlm">(1.4)</a> comme des variables indépendantes prédisant le score à la variable dépendante <span class="math inline">\(y_i\)</span>. C’est d’ailleurs pourquoi dans un diagramme de modélisation par équations structurelle les flèches pointent des facteurs vers les variables. Par souci du détail, il faudrait, pour une représentation parfaite, mentionner les participants (donc un troisième indice), mais cela est évité ici pour simplifier la présentation.</p>
<p>Trêve de digression, il ne restait plus qu’à faire le produit matricielle de <code>Struct.Fact</code> (<span class="math inline">\(\left[ \Phi, \text{diag}(\epsilon) \right]\)</span>) et des scores individuelles (<code>score.ind</code>).</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n</span> <span class="op">=</span> <span class="fl">10</span>; <span class="va">k</span> <span class="op">=</span> <span class="fl">2</span>; <span class="va">p</span> <span class="op">=</span> <span class="fl">6</span>
<span class="va">score.ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="va">n</span> <span class="op">*</span> <span class="va">p</span> <span class="op">*</span> <span class="va">k</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="op">(</span><span class="va">k</span> <span class="op">+</span> <span class="va">p</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">n</span><span class="op">)</span>
<span class="va">score</span> <span class="op">=</span> <span class="va">Struct.Fact</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">score.ind</span> </code></pre></div>
<p>La variable <code>score</code> contient tous les scores des <span class="math inline">\(n\)</span> participants sur les <span class="math inline">\(p\)</span> variables. Pour obtenir la base de données dans le sens usuel, il suffit de faire une transpose à <code>score</code> avec la fonction <code><a href="https://rdrr.io/r/base/t.html">t()</a></code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">jd</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">score</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">jd</span><span class="op">)</span>
<span class="co">#&gt;          i1     i2     i3     i4     i5     i6</span>
<span class="co">#&gt; [1,]  0.345  1.295  0.904 -0.896 -2.213 -1.331</span>
<span class="co">#&gt; [2,]  1.206  0.461  1.621 -0.715 -0.571  0.320</span>
<span class="co">#&gt; [3,] -0.722 -1.062 -1.418 -1.867  0.855 -2.295</span>
<span class="co">#&gt; [4,] -2.641 -2.269 -1.415 -1.210 -0.876 -0.746</span>
<span class="co">#&gt; [5,] -1.326 -1.284 -1.240  0.687  1.843 -0.868</span>
<span class="co">#&gt; [6,]  0.693  0.759  0.963  1.250 -0.148  1.154</span></code></pre></div>
<p>Voilà une base de données prêtes à être utiliser pour une analyse factorielle. En pratique, pour donner un peu plus de réalisme, il est possible d’ajouter une moyenne (additionner), de modifier l’écart type (multiplier) de chacune des variables, d’arrondir les scores, et plus en fonction des besoins.</p>
</div>
<div id="syntaxe" class="section level2" number="1.4">
<h2>
<span class="header-section-number">1.4</span> Syntaxe<a class="anchor" aria-label="anchor" href="#syntaxe"><i class="fas fa-link"></i></a>
</h2>
<p>Il existe plusieurs fonctions dans <strong>R</strong>, mais aussi dans des packages, pour réaliser l’ACP. L’analyse en soi n’a rien de sorcier (en autant que les statisticiens ne font pas de magie), c’est surtout l’emballage (graphiques et sorties) qui changera de l’une à l’autre des méthodes. Elles précalculent et extraient les statistiques désirées, rien que l’utilisateur ne peut faire lui-même.</p>
<p>L’analyse de décomposition en valeurs singulières (<em>singular value decomposition</em>, SVD) est généralement recommandée, car elle est computationnellement plus robuste que l’ACP. Un puriste choisierait probablemetn la fonction <code><a href="https://rdrr.io/r/base/eigen.html">eigen()</a></code> à la place, mais les résultats seraient virtuellement identiques. Ces deux fonctions prennent comme argument une matrice de covariance ou de corrélation.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># L'ACP se commande avec svd() avec comme </span>
<span class="co"># argument une matrice de corrélation des données</span>
<span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">jd</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>La fonction <code><a href="https://rdrr.io/r/base/svd.html">svd()</a></code> permettra de faire l’analyse. Elle produit trois matrices. La première <code>$d</code> contient les valeurs propres que l’on peut extraire avec <code>res$d</code> Les deux autres sont les projections et seront utiles pour calculer les loadings et les communalités Pour les loadings, il faut calculer le produit de de la projection <span class="math inline">\(U\)</span> par la racine carré des valeurs propres comme à l’équation <a href="lanalyse-en-composantes-principales.html#eq:load">(1.5)</a>,</p>
<p><span class="math display" id="eq:load">\[\begin{equation}
F = U d^{1/2}
\tag{1.5}
\end{equation}\]</span></p>
<p>où <code>F</code> remplace <code>phi</code>, car il s’agit d’une estimation sur un échantillon et non plus des paramètres de la population. Les communalités se calculent comme à l’équation <a href="lanalyse-en-composantes-principales.html#eq:com">(1.1)</a>, soit le carré des loading.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># ACP</span>
<span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">jd</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Extraction des données</span>
<span class="va">eigenvalues</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">d</span>
<span class="va">loadings</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">d</span> <span class="op">^</span> <span class="fl">0.5</span><span class="op">)</span>
<span class="va">communalites</span> <span class="op">=</span> <span class="va">loadings</span><span class="op">^</span><span class="fl">2</span></code></pre></div>
<p>Il est possible d’utiliser la syntaxe précédente et d’en faire une fonction.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mon.acp</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">jd</span><span class="op">)</span><span class="op">{</span>
  <span class="va">R</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">jd</span><span class="op">)</span>
  <span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span>
  <span class="va">eigenvalues</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">d</span>
  <span class="va">loadings</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">u</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">d</span> <span class="op">^</span> <span class="fl">0.5</span><span class="op">)</span>
  <span class="va">communalites</span> <span class="op">=</span> <span class="va">loadings</span><span class="op">^</span><span class="fl">2</span>
  <span class="va">statistique</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>valeurs.propres <span class="op">=</span> <span class="va">eigenvalues</span>,
                     loadings <span class="op">=</span> <span class="va">loadings</span>,
                     communalites <span class="op">=</span> <span class="va">communalites</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>À des fins de comparaisons, la création de données est réitérés, mais avec 5000 participants avec la même structure factorielle à deux facteurs et 6 variables.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Pour reproductibilité</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">9876</span><span class="op">)</span>
<span class="co"># Créer des scores individuels</span>
<span class="co"># pour 5000 participants, deux facteurs et 6</span>
<span class="va">n</span> <span class="op">=</span> <span class="fl">5000</span>; <span class="va">k</span> <span class="op">=</span> <span class="fl">2</span>; <span class="va">p</span> <span class="op">=</span> <span class="fl">6</span>
<span class="va">score.ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="va">n</span> <span class="op">*</span> <span class="va">p</span> <span class="op">*</span> <span class="va">k</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="op">(</span><span class="va">k</span> <span class="op">+</span> <span class="va">p</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">n</span><span class="op">)</span>
<span class="co"># Multiplier à la structure factorielle</span>
<span class="co"># Struct.Fact est créé auparavant</span>
<span class="va">score</span> <span class="op">=</span> <span class="va">Struct.Fact</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">score.ind</span> 
<span class="co"># Orienter sujet en ligne et variable en colonne</span>
<span class="va">jd5000</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">score</span><span class="op">)</span>
<span class="co"># ACP</span>
<span class="va">res</span> <span class="op">=</span> <span class="fu">mon.acp</span><span class="op">(</span><span class="va">jd5000</span><span class="op">)</span></code></pre></div>
<p>Voici une comparaison des loadings par rapport à <span class="math inline">\(\Phi\)</span>, les deux sont très près. Seules les deux première composantes sont extraites, car la solution est connue par le lecteur.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Pour comparaison</span>
<span class="va">phi</span> ; <span class="va">res</span><span class="op">$</span><span class="va">loadings</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>
<span class="co">#&gt;     F1  F2</span>
<span class="co">#&gt; i1 0.9 0.0</span>
<span class="co">#&gt; i2 0.8 0.0</span>
<span class="co">#&gt; i3 0.7 0.0</span>
<span class="co">#&gt; i4 0.0 0.6</span>
<span class="co">#&gt; i5 0.0 0.5</span>
<span class="co">#&gt; i6 0.4 0.4</span>
<span class="co">#&gt;        [,1]   [,2]</span>
<span class="co">#&gt; [1,] -0.887  0.152</span>
<span class="co">#&gt; [2,] -0.848  0.165</span>
<span class="co">#&gt; [3,] -0.793  0.158</span>
<span class="co">#&gt; [4,] -0.110 -0.783</span>
<span class="co">#&gt; [5,] -0.102 -0.751</span>
<span class="co">#&gt; [6,] -0.571 -0.415</span></code></pre></div>
<p>Cela dit, deux caractéristiques sont différentes. La première est que la plupart des valeurs sont négatives. L’ACP estime dans des dimensions à la polarité arbitraire, ainsi les valeurs négatives et positives sont arbitraires, l’important étant que si la polarité est inversée, comme par <code>-res$loadings</code>, elle doit l’être pour toutes les valeurs.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">-</span><span class="va">res</span><span class="op">$</span><span class="va">loadings</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>
<span class="co">#&gt;       [,1]   [,2]</span>
<span class="co">#&gt; [1,] 0.887 -0.152</span>
<span class="co">#&gt; [2,] 0.848 -0.165</span>
<span class="co">#&gt; [3,] 0.793 -0.158</span>
<span class="co">#&gt; [4,] 0.110  0.783</span>
<span class="co">#&gt; [5,] 0.102  0.751</span>
<span class="co">#&gt; [6,] 0.571  0.415</span></code></pre></div>
<p>La seconde différences est que les valeurs ne sont pas exactement les mêmes malgré les 5000 participants. Cela est aussi vraie pour les loadings nuls (fixé à 0 au départ); ils ne sont plus nuls, mais légèrement supérieurs. Cela s’explique par le fait que l’ACP est une technique d’analyse opportuniste qui capitalise sur la variance partagée. Il y a des résidus accidentellement corrélés aux facteurs, et ces corrélations sont pris en compte dans les facteurs. Une explication supplémentaire est aussi de se rappeler que le jeu de données est créés sur <span class="math inline">\(k + p = 2+6=8\)</span> dimensions alors que le jeu de données, lui, n’en a que <span class="math inline">\(p = 6\)</span>. Il y inévitablement deux dimensions à écraser dans les six autres.</p>
</div>
<div id="rotation-varimax" class="section level2" number="1.5">
<h2>
<span class="header-section-number">1.5</span> Rotation varimax<a class="anchor" aria-label="anchor" href="#rotation-varimax"><i class="fas fa-link"></i></a>
</h2>
<p>Les axes des loadings pour <span class="math inline">\(m\)</span> facteurs sont basés sur la réorganisation des <span class="math inline">\(p\)</span> variables. Cela induit la présence de déviations pour tenir compte des erreurs laissées dans les dernières variables. Une dernière étape pour réorganiser la variance de façon optimale est d’user d’une rotation des axes. Essentiellement, la fonction tentera de maximiser la loadings les plus élevés (en termes absolu) et de réduire celles les plus près de 0 en ne tenant compte que des <span class="math inline">\(m\)</span> axes à retenir sans tenir compte des <span class="math inline">\(p-m\)</span> autres axes.</p>
<p>Pour réaliser une rotation, la fonction <strong>R</strong> de base <code><a href="https://rdrr.io/r/stats/varimax.html">varimax()</a></code> accomplira la tâche. Il s’agit d’une rotation orthogonale, rotation selon laquelle les facteurs demeurent indépendants, donc non corrélés. Comme argument, il faut spécifier les loadings pour le nombre de dimensions désirées.</p>
<p>La syntaxe ci-dessous détermine le nombre d’axes à retenir, <span class="math inline">\(m=2\)</span>, sélection ces axes qui se trouvent dans la variable <code>res</code> sous la colonne <code>loadings</code>, ainsi <code>res$loadings[,1:m]</code> extrait les loadings des 1 à <span class="math inline">\(m\)</span> dimensions.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Prendre les loadings du nombre de dimensions désirées </span>
<span class="va">m</span> <span class="op">&lt;-</span>  <span class="fl">2</span>    <span class="co"># Nombre de dimensions désirées</span>
<span class="va">res.rot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/varimax.html">varimax</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">loadings</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="va">m</span><span class="op">]</span><span class="op">)</span>
<span class="va">res.rot</span>
<span class="co">#&gt; $loadings</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Loadings:</span>
<span class="co">#&gt;      [,1]   [,2]  </span>
<span class="co">#&gt; [1,] -0.900       </span>
<span class="co">#&gt; [2,] -0.864       </span>
<span class="co">#&gt; [3,] -0.808       </span>
<span class="co">#&gt; [4,]        -0.790</span>
<span class="co">#&gt; [5,]        -0.757</span>
<span class="co">#&gt; [6,] -0.484 -0.513</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;                 [,1]  [,2]</span>
<span class="co">#&gt; SS loadings    2.447 1.461</span>
<span class="co">#&gt; Proportion Var 0.408 0.244</span>
<span class="co">#&gt; Cumulative Var 0.408 0.651</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $rotmat</span>
<span class="co">#&gt;        [,1]  [,2]</span>
<span class="co">#&gt; [1,]  0.983 0.185</span>
<span class="co">#&gt; [2,] -0.185 0.983</span></code></pre></div>
<p>La sortie de <code><a href="https://rdrr.io/r/stats/varimax.html">varimax()</a></code> est enregistrée dans <code>res.rot</code>. Elle offre deux informations importantes. La première est les nouveaux loadings après la rotation, sous <code>res.rot$loadings</code>. Tout de suite, il appert que ces loadings sont plus près que les originaux, mais pas tant différent (ce qui est normal considérant la taille d’échantillon élevée et le peu de variable). Également, les loadings <em>marginaux</em> (près de 0) ne sont pas affichés. Ceux ci peuvent être extraits en les spécifiant avec les crochets dans <code>res.rot$loadings[]</code>.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Extraire le premier loading du deuxième facteur</span>
<span class="va">res.rot</span><span class="op">$</span><span class="va">loadings</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span>
<span class="co">#&gt; [1] -0.864</span></code></pre></div>
<p>La deuxième est la matrice de rotation dans <code>res.rot$rotmat</code> qui correspond au pivot selon lequel les loadings ont été remaniés. Les statistiques <code>SS loadings</code>, <code>Proportion Var</code> et <code>Cumulative Var</code> sont calculés à partir des loadings et ne peuvent être extraits. Ils sont présentés à titre informatif seulement.</p>
<p>Il existe déjà dans <strong>R</strong> de base également une fonction permettant de faire une rotation oblique, dont les facteurs peuvent être corrélés, nommée <code><a href="https://rdrr.io/r/stats/varimax.html">promax()</a></code>.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/stats/varimax.html">promax</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">loadings</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; $loadings</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Loadings:</span>
<span class="co">#&gt;      [,1]   [,2]  </span>
<span class="co">#&gt; [1,] -0.907       </span>
<span class="co">#&gt; [2,] -0.873       </span>
<span class="co">#&gt; [3,] -0.817       </span>
<span class="co">#&gt; [4,]  0.113 -0.802</span>
<span class="co">#&gt; [5,]  0.112 -0.769</span>
<span class="co">#&gt; [6,] -0.439 -0.484</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;                 [,1]  [,2]</span>
<span class="co">#&gt; SS loadings    2.470 1.480</span>
<span class="co">#&gt; Proportion Var 0.412 0.247</span>
<span class="co">#&gt; Cumulative Var 0.412 0.658</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $rotmat</span>
<span class="co">#&gt;        [,1]  [,2]</span>
<span class="co">#&gt; [1,]  0.974 0.116</span>
<span class="co">#&gt; [2,] -0.281 1.008</span></code></pre></div>
<p>La sortie offre les mêmes informations que <code><a href="https://rdrr.io/r/stats/varimax.html">varimax()</a></code> auparavant. Les résultats sont toutefois différents puisque la rotation est oblique (les facteurs peuvent être corrélés) alors qu’elle était orthogonale sous <code><a href="https://rdrr.io/r/stats/varimax.html">varimax()</a></code>. À noter, la matrice de rotation n’est pas une matrice de corrélation entre facteurs.</p>
<p>Dans cet exemple, les facteurs sont orthogonaux tel que défini par l’utilisateur au départ. La fonction <code><a href="https://rdrr.io/r/stats/varimax.html">promax()</a></code> n’est donc pas nécessaire ici, aucune corrélation entre facteur n’étant spécifiée.</p>
</div>
<div id="dimensions-corrélées" class="section level2" number="1.6">
<h2>
<span class="header-section-number">1.6</span> Dimensions corrélées<a class="anchor" aria-label="anchor" href="#dimensions-corr%C3%A9l%C3%A9es"><i class="fas fa-link"></i></a>
</h2>
<p>Pour créer un jeu de données ayant une structure factorielle avec dimensions corrélées, une des méthodes les plus simples est de passer par la matrice de corrélation. Pour suivre cette approche, il faut spécifier une structure factorielle <span class="math inline">\(\Phi\)</span> (comme c’était le cas jusqu’ici), en plus d’une matrice de corrélation pour les facteurs, <span class="math inline">\(\mathbf{R}_\Phi\)</span>. En suivant l’équation <a href="lanalyse-en-composantes-principales.html#eq:corfact">(1.6)</a>, cela produit la matrice corrélation (sans erreur) du jeu de données, noté <span class="math inline">\(\mathbf{R}^*\)</span>, l’étoile mentionnant que ce n’est pas une matrice de corrélation encore.</p>
<p><span class="math display" id="eq:corfact">\[\begin{equation}
\mathbf{R}^* = \Phi \mathbf{R}_\Phi \Phi^\prime
\tag{1.6}
\end{equation}\]</span></p>
<p>Pour ajouter l’erreur, il reste à fixer la diagonale de la matrice <span class="math inline">\(\mathbf{R}\)</span> à 1, comme l’équation <a href="lanalyse-en-composantes-principales.html#eq:diag1">(1.7)</a>.</p>
<p><span class="math display" id="eq:diag1">\[\begin{equation}
\mathbf{R} = \text{diag}(\mathbf{R}^*) \leftarrow 1
\tag{1.7}
\end{equation}\]</span></p>
<p>Cette matrice de corrélation peut maintenant être utilisée avec <code><a href="https://rdrr.io/pkg/MASS/man/mvrnorm.html">MASS::mvrnorm()</a></code> pour obtenir des données. Voici la syntaxe <strong>R</strong> pour cet usage.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Création de la matrice de corrélation entre facteurs</span>
<span class="va">Rphi</span> <span class="op">&lt;-</span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">.3</span>, <span class="fl">.3</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">Rphi</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"F1"</span>,<span class="st">"F2"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">Rphi</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"F1"</span>,<span class="st">"F2"</span><span class="op">)</span>
<span class="co"># Afficher phi et Rphi</span>
<span class="va">phi</span> ; <span class="va">Rphi</span>
<span class="co">#&gt;     F1  F2</span>
<span class="co">#&gt; i1 0.9 0.0</span>
<span class="co">#&gt; i2 0.8 0.0</span>
<span class="co">#&gt; i3 0.7 0.0</span>
<span class="co">#&gt; i4 0.0 0.6</span>
<span class="co">#&gt; i5 0.0 0.5</span>
<span class="co">#&gt; i6 0.4 0.4</span>
<span class="co">#&gt;     F1  F2</span>
<span class="co">#&gt; F1 1.0 0.3</span>
<span class="co">#&gt; F2 0.3 1.0</span>

<span class="co"># Création de la matrice de corrélation des items à partir</span>
<span class="co"># des facteurs et leur corrélation</span>
<span class="va">R</span> <span class="op">&lt;-</span>  <span class="va">phi</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">Rphi</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">phi</span><span class="op">)</span>

<span class="co"># Afficher R (sans erreur)</span>
<span class="va">R</span>
<span class="co">#&gt;       i1    i2    i3    i4    i5    i6</span>
<span class="co">#&gt; i1 0.810 0.720 0.630 0.162 0.135 0.468</span>
<span class="co">#&gt; i2 0.720 0.640 0.560 0.144 0.120 0.416</span>
<span class="co">#&gt; i3 0.630 0.560 0.490 0.126 0.105 0.364</span>
<span class="co">#&gt; i4 0.162 0.144 0.126 0.360 0.300 0.312</span>
<span class="co">#&gt; i5 0.135 0.120 0.105 0.300 0.250 0.260</span>
<span class="co">#&gt; i6 0.468 0.416 0.364 0.312 0.260 0.416</span>

<span class="co"># Inclure l'erreur en fixant la diagonale à 1</span>
<span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">1</span>
<span class="va">R</span>
<span class="co">#&gt;       i1    i2    i3    i4    i5    i6</span>
<span class="co">#&gt; i1 1.000 0.720 0.630 0.162 0.135 0.468</span>
<span class="co">#&gt; i2 0.720 1.000 0.560 0.144 0.120 0.416</span>
<span class="co">#&gt; i3 0.630 0.560 1.000 0.126 0.105 0.364</span>
<span class="co">#&gt; i4 0.162 0.144 0.126 1.000 0.300 0.312</span>
<span class="co">#&gt; i5 0.135 0.120 0.105 0.300 1.000 0.260</span>
<span class="co">#&gt; i6 0.468 0.416 0.364 0.312 0.260 1.000</span>

<span class="co"># Générer les données</span>
<span class="va">jd5000.2</span> <span class="op">&lt;-</span> <span class="fu">MASS</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/MASS/man/mvrnorm.html">mvrnorm</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n</span>, mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">p</span><span class="op">)</span>, Sigma <span class="op">=</span> <span class="va">R</span><span class="op">)</span></code></pre></div>
<p>Par la suite, les étapes de l’ACP sont réalisables comme auparavant.</p>
</div>
<div id="calculs" class="section level2" number="1.7">
<h2>
<span class="header-section-number">1.7</span> Calculs<a class="anchor" aria-label="anchor" href="#calculs"><i class="fas fa-link"></i></a>
</h2>
<p><em>À terminer</em></p>
<!-- ```{r} -->
<!-- mon.svd <- function(S){ -->
<!-- Dim <- dim(S) -->
<!-- U <-  diag(Dim[1]) -->
<!-- V <-  diag(Dim[2]) -->
<!-- tol <- (max(abs(S)))*1e-1 -->
<!-- Arem <- Inf -->
<!-- while (Arem > tol) { -->
<!--   z <- qr(S) -->
<!--   Q <- qr.Q(z) -->
<!--   R <- qr.R(z) -->
<!--   U <- U %*% Q -->
<!--   z <- qr(t(R)) -->
<!--   Q <- qr.Q(z) -->
<!--   R <- qr.R(z)  -->
<!--   V <- V %*% Q -->
<!--   A <- t(R) -->
<!--   A[upper.tri(A)] <- 0 -->
<!--   Arem <- norm(A, type = "I") -->
<!-- } -->
<!-- U <- U[,1:m] -->
<!-- S <- upper.tri(A[1:m,]) -->
<!-- } -->
<!-- ``` -->
<!-- Une technique un peu plus robuste et générale est la décomposition en valeur singulière (*singular valeur decomposition*). -->
<!-- Pour le lecteur de cet ouvrage, il n'y a que peu de différence à faire entre les deux. Les différences sont ... -->
</div>
<div id="réduction-des-dimensions" class="section level2" number="1.8">
<h2>
<span class="header-section-number">1.8</span> Réduction des dimensions<a class="anchor" aria-label="anchor" href="#r%C3%A9duction-des-dimensions"><i class="fas fa-link"></i></a>
</h2>
<p>Comme mentionné d’entrer de jeu, l’ACP n’est pas une technique de réduction des dimensions, s’il y a <span class="math inline">\(p\)</span> variables, l’ACP produit <span class="math inline">\(p\)</span> dimensions, mais comme elle maximise l’information dans les premières composantes, elle peut être utilisée comme telle. La question devient, comment de dimensions faut-il retenir pour rendre adéquatement compte des données. Dès lors, l’ACP devient une technique de réduction des dimension, mais comme elle ne répond pas explicitement à cette question, le statisticien usera de techniques complémentaires, des règles d’arrêts (<em>stopping rules</em>) pour déterminer le nombre de dimensions.</p>
<p>Ces règles d’arrêt sont en général un <em>bricolage</em> du statisticien pour répondre à la question. Bricolage n’est pas à prendre péjorativement, mais seulement comme rappel à la réalité que ces techniques sont souvent créées sans justificatifs théoriques, comme une dérivation analytique, et il n’est pas possible de leur faire aveuglément confiance (il ne faudrait jamais faire cela en science de toute façon). Elles sont une pertinence pratique, mais les conditions dans lesquelles elles flanchent n’est pas connue. Il existe probablement des centaines de techniques ayant leur avantage et inconvénients ou bien des scénarios dans lesquels elles sont plus efficaces que les autres. Il en apparaît des nouvelles chaque années depuis 1950. Comme ces techniques sont des bricolages et qu’elles sont taillées différemment, elles ne résulteront pas toutes à la même conclusion. Faire l’étalage de ces règles d’arrêt serait bien inutile. Ainsi, les deux techniques les plus utilisées seront présentées, l’analyse parallèle (<em>parallel analysis</em>) et la corrélation partielle moyenne minimale (<em>minimum average partial correlation</em>). Une troisième méthode ayant montré un excellent rendement sera présentée, soit le test séquentiel de la prochaine valeur propre (<em>Next eigenvalue sequence test</em>).</p>
</div>
<div id="illustration" class="section level2" number="1.9">
<h2>
<span class="header-section-number">1.9</span> Illustration<a class="anchor" aria-label="anchor" href="#illustration"><i class="fas fa-link"></i></a>
</h2>
<p>La compression d’images est un exemple ou la réduction de dimension permet de résumer l’information afin d’en réduire la taille pour ne conserver que le signifiant. Ainsi, les mêmes techniques permettant d’identifier les facteurs psychologiques peuvent être utilisées pour les images, mais l’identification des thèmes de films et bien d’autres.</p>
<p>La Figure <a href="lanalyse-en-composantes-principales.html#fig:Pigeon">1.3</a> montre un exemple de compression d’une image de pigeon<a href="r%C3%A9f%C3%A9rences.html#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>. Elle montre à différents niveaux factoriels de compression la même image. À trois dimensions, le pigeon est difficilement perceptible. Progressivement, le pigeon est plus facilement reconnaissable, mais surtout, à un certain seuil (deuxième et troisième lignes de la Figure <a href="lanalyse-en-composantes-principales.html#fig:Pigeon">1.3</a>, par exemple), l’image gagne en clarté. Trente dimensions conviennent, les plus difficiles désireront peut-être retenir 125 dimensions. L’image à ce niveau est très bien. Nonobstant ces nombres, ce sera toujours mieux, en termes de compression, que les 526 dimensions possibles. Ainsi, à 23.764 % des dimensions, l’image est claire et le pigeon reconnaissable. Cette logique s’applique également pour les facteurs psychologiques.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:Pigeon"></span>
<img src="image/Pigeon.pdf" alt="Pigeon compressé à divers niveaux de dimension $k$" height="150%"><p class="caption">
Figure 1.3: Pigeon compressé à divers niveaux de dimension <span class="math inline">\(k\)</span>
</p>
</div>
</div>
<div id="importance-dune-dimension" class="section level2" number="1.10">
<h2>
<span class="header-section-number">1.10</span> Importance d’une dimension<a class="anchor" aria-label="anchor" href="#importance-dune-dimension"><i class="fas fa-link"></i></a>
</h2>
<p>Une technique pour connaître l’importance d’une dimension est d’afficher les valeurs propres. Les valeurs propres les plus élevées impliquent les plus importantes (les premières) alors que de petites valeurs signalent les moins importantes (du bruit, soit les dernières). Il est toutefois plus ardu de déterminer le seuil entre important et non important.</p>
<p>Une façon d’illustrer les valeurs propres graphiquement est d’utilisre un graphique nommé <em>scree plot</em> ou <em>grahpique des éboulis</em>. La Figure <a href="lanalyse-en-composantes-principales.html#fig:scree">1.4</a> peut être produite avec la syntaxe ci-dessous. Il s’agit de mettre en axe des <span class="math inline">\(x\)</span> la séquence (<code>idex</code>) des valeurs propres (leur ordre) par rapport à la valeur propre en axe des <span class="math inline">\(y\)</span>. Ce graphique se produit simplement avec <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>. L’option <code>type = "b"</code> est simplement un type de graphique utilisé, dans ce cas-ci, la combinaison de points et de lignes.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">valeurs.propres</span>,
     type <span class="op">=</span> <span class="st">"b"</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:scree"></span>
<img src="14-ACP_files/figure-html/scree-1.png" alt="Les valeurs propres en fonctions de la position de l'axe" width="672"><p class="caption">
Figure 1.4: Les valeurs propres en fonctions de la position de l’axe
</p>
</div>
</div>
<div id="lanalyse-parallèle" class="section level2" number="1.11">
<h2>
<span class="header-section-number">1.11</span> L’analyse parallèle<a class="anchor" aria-label="anchor" href="#lanalyse-parall%C3%A8le"><i class="fas fa-link"></i></a>
</h2>
<p>Avant d’introduire l’analyse parallèle (PA), il est intéressant de présenter le test duquel il est inspiré, soit le <em>test de Kaiser</em> <span class="citation">(<a href="r%C3%A9f%C3%A9rences.html#ref-Kaiser" role="doc-biblioref">Kaiser, 1960</a>)</span>. C’est le test utilisé par défaut dans certains logiciel traditionnel, malgré qu’il soit discrédité depuis plusieurs années <span class="citation">(<a href="r%C3%A9f%C3%A9rences.html#ref-Achim20" role="doc-biblioref">Achim, 2020</a>; <a href="r%C3%A9f%C3%A9rences.html#ref-Beauducel01" role="doc-biblioref">Beauducel, 2001</a>; <a href="r%C3%A9f%C3%A9rences.html#ref-Turner98" role="doc-biblioref">Turner, 1998</a>)</span>. Ce test se fonde sur l’idée selon laquelle, si les variables ne sont pas corrélées entre elles, donc s’il n’y a pas de facteurs, les valeurs propres seront égales à 1. La logique du test est d’affirmer que, si une valeur propre est supérieure à 1, alors de l’information commune est nécessairement partagée entre deux ou plusieurs variables. Selon le test de Kaiser, le nombre de composantes à retenir correspond au nombre de valeurs propres supérieures à 1.</p>
<p>Asymptotiquement parlant, si <span class="math inline">\(n \to \infty\)</span>, le test est vraie. Par contre, l’ACP capitalise sur l’erreur et en inclut accidentellement dans les premières dimensions. Conséquemment, les premiers axes seront surestimés, alors que les derniers seront sous-estimées.</p>
<p>La solution proposée par <span class="citation">Horn (<a href="r%C3%A9f%C3%A9rences.html#ref-Horn65" role="doc-biblioref">1965</a>)</span> est alors de tenir compte de cette erreur d’échantillonnage accidentelle. Pour ce faire, il propose de rééchantillonner les valeurs propres d’un jeu de données sans aucun facteur (aucune corrélation entre les variables) et ayant les mêmes caractéristiques que le jeu de données cible (même nombre de variables et de participant). Le jeu de données cible correspond au jeu de données de l’expérimentateur. Même s’il n’y a pas de corrélation sur le plan de la population, il y aura accidentellement des corrélations dans un échantillon. Le rééchantillonnage est réitéré sur des milliers de jeu de données artificiel. À chaque fois, les valeurs propres sont enregistrées. Des moyennes en sont retirés à la toute fin. Il s’agit du critère auquel l’hypothèse nulle est rejetée. De la première à la dernière, chaque valeur propre cible est comparée à la valeur propre moyenne correspondante, si la cible est plus élevée, il s’agit d’une dimension à retenir. Dès que la cible est inférieur, le test est arrêté. Le nombre de valeurs propres supérieures aux valeurs propres artificielles correspond au nombre de dimensions à retenir.</p>
<p>Dans la syntaxe ci-dessous, les mêmes caractéristiques que le jeu de données précédent sont utilisés, soit <span class="math inline">\(p = 6\)</span> et <span class="math inline">\(n = 5000\)</span>. À la fin, il sera possible de comparer s’il y a effectivement deux facteurs selon l’AP.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1019</span><span class="op">)</span>
<span class="va">p</span> <span class="op">=</span> <span class="fl">6</span>        <span class="co"># Nombre de variables</span>
<span class="va">n</span> <span class="op">=</span> <span class="fl">5000</span>     <span class="co"># Nombre de participants </span>
<span class="va">reps</span> <span class="op">=</span> <span class="fl">1000</span>  <span class="co"># Nombre d'itérations</span>
<span class="va">valeurs.propres</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,           <span class="co"># Création d'une variable</span>
                         nrow <span class="op">=</span> <span class="va">p</span>,    <span class="co"># vide pour enregistrer</span>
                         ncol <span class="op">=</span> <span class="va">reps</span><span class="op">)</span> <span class="co"># les valeurs propres</span>
<span class="co"># Création de la boucle                                        </span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">reps</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">score</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n</span> <span class="op">*</span> <span class="va">p</span><span class="op">)</span>             <span class="co"># Création de n * p valeurs </span>
                                       <span class="co"># aléatoires non corrélées</span>
  <span class="va">D</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="va">score</span>,                    <span class="co"># Formater en matrice le jeu</span>
             nrow <span class="op">=</span> <span class="va">n</span>, ncol <span class="op">=</span> <span class="va">p</span><span class="op">)</span>       <span class="co"># de données </span>
  <span class="va">ACP</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">D</span><span class="op">)</span><span class="op">)</span>                    <span class="co"># Réaliser l'ACP </span>
  <span class="va">valeurs.propres</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">ACP</span><span class="op">$</span><span class="va">d</span>          <span class="co"># Enregistrer les valeurs propres</span>
<span class="op">}</span>

<span class="co"># Une fois les valeurs propres obtenues,</span>
<span class="co"># les moyennes et quantiles sont calculables</span>
<span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="va">valeurs.propres</span><span class="op">)</span>        <span class="co"># Une moyenne par ligne (valeur propres)</span>
<span class="co">#&gt; [1] 1.047 1.025 1.008 0.992 0.975 0.954</span>

<span class="co"># Ou si le 95e percentile était préféré</span>
<span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">valeurs.propres</span>, 
      FUN <span class="op">=</span> <span class="va">quantile</span>,
      MARGIN <span class="op">=</span> <span class="fl">1</span>,
      probs <span class="op">=</span> <span class="fl">.95</span><span class="op">)</span>
<span class="co">#&gt; [1] 1.065 1.038 1.019 1.001 0.986 0.969</span></code></pre></div>
<p>Pour connaître le nombre de dimension, il suffit de tester les valeurs propres empiriques et les comparer aux valeurs propres simulées (moyenne ou 95<sup>e</sup> percentile). Le nombre de valeur propre empirique supérieur aux valeurs propres simulés correspond au nombre de composantes à retenir.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Les valeurs propres empiriques</span>
<span class="va">res</span><span class="op">$</span><span class="va">valeurs.propres</span>
<span class="co">#&gt; [1] 2.483 1.425 0.715 0.648 0.468 0.260</span>

<span class="co"># La moyenne des valeurs propres simulées</span>
<span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="va">valeurs.propres</span><span class="op">)</span>
<span class="co">#&gt; [1] 1.047 1.025 1.008 0.992 0.975 0.954</span>

<span class="co"># Nombre de valeurs propres empiriques supérieures aux simulées</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">valeurs.propres</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="va">valeurs.propres</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p>Ainsi, 2 facteurs sont à retenir. Une façon d’illustrer les résultats de l’analyse parallèle est d’utiliser le graphique de éboulis en y représentant les valeurs propres empiriques comparativement aux simulées. Le nombre de valeurs propres empiriques supérieures aux simulées est le nombre de dimensions à retenir. Ce graphique est produit à la Figure <a href="lanalyse-en-composantes-principales.html#fig:scree2">1.5</a>. Voici la syntaxe pour produire ce graphique avec <code>ggplot2</code>. La première étape est de mettre en commun les résultats obtenus dans un jeu de données. La variable <code>Index</code> indique l’index de la valeur propres, <code>valeurs.propres</code> contient les valeurs propres et <code>Type</code> indique s’il s’agit de valeurs propres empiriques ou simulées de l’analyse parallèle. Pour le reste, il s’agit de recourir à <code>ggplot()</code>.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>Index <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">p</span>, <span class="va">p</span><span class="op">)</span>,
           valeurs.propres <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">valeurs.propres</span>, <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="va">valeurs.propres</span><span class="op">)</span><span class="op">)</span>,
           Type <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Empirique"</span>,<span class="st">"Simulées"</span><span class="op">)</span>, each <span class="op">=</span> <span class="va">p</span><span class="op">)</span>
<span class="op">)</span> <span class="op">%&gt;%</span> 
  <span class="fu">ggplot</span><span class="op">(</span>mapping <span class="op">=</span> <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">Index</span>, y <span class="op">=</span> <span class="va">valeurs.propres</span>, color <span class="op">=</span> <span class="va">Type</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">geom_line</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">geom_point</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">theme</span><span class="op">(</span>legend.position <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.8</span>, <span class="fl">0.8</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:scree2"></span>
<img src="14-ACP_files/figure-html/scree2-1.png" alt="Comparaison des valeurs propres empiriques et simulées" width="672"><p class="caption">
Figure 1.5: Comparaison des valeurs propres empiriques et simulées
</p>
</div>
</div>
<div id="map" class="section level2" number="1.12">
<h2>
<span class="header-section-number">1.12</span> MAP<a class="anchor" aria-label="anchor" href="#map"><i class="fas fa-link"></i></a>
</h2>
<p><em>À terminer</em></p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">MAP</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">...</span><span class="op">)</span><span class="op">{</span>
  
  <span class="va">ns</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
  <span class="va">nv</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>
  
  <span class="kw">if</span><span class="op">(</span><span class="va">ns</span><span class="op">==</span><span class="va">nv</span><span class="op">)</span><span class="op">{</span>
    <span class="va">R</span> <span class="op">=</span> <span class="va">data</span>
  <span class="op">}</span><span class="kw">else</span><span class="op">{</span>
    <span class="va">R</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>
  <span class="op">}</span>
  
  <span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span>
  <span class="va">loadings</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">vectors</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">values</span><span class="op">)</span><span class="op">)</span>
  
  <span class="va">fm</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">nv</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">nv</span><span class="op">)</span><span class="op">)</span>
  <span class="va">fm</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">R</span> <span class="op">^</span> <span class="fl">2</span><span class="op">)</span> <span class="op">-</span> <span class="va">nv</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">nv</span> <span class="op">*</span> <span class="op">(</span><span class="va">nv</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
  
  <span class="kw">for</span> <span class="op">(</span><span class="va">m</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">nv</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span>
    <span class="va">A</span> <span class="op">=</span> <span class="va">loadings</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="va">m</span><span class="op">]</span>
    <span class="va">partcov</span> <span class="op">=</span> <span class="va">R</span> <span class="op">-</span> <span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">)</span>
    <span class="va">d</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span> <span class="op">(</span><span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">partcov</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
    <span class="va">pr</span> <span class="op">=</span> <span class="va">d</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">partcov</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">d</span>
    <span class="va">fm</span><span class="op">[</span><span class="va">m</span><span class="op">+</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span>  <span class="op">=</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">pr</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">-</span> <span class="va">nv</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">nv</span> <span class="op">*</span> <span class="op">(</span><span class="va">nv</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
  <span class="op">}</span>
  
  <span class="va">minfm</span> <span class="op">=</span> <span class="va">fm</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span>
  <span class="va">nfact</span> <span class="op">=</span> <span class="fl">0</span>
  <span class="kw">for</span> <span class="op">(</span><span class="va">s</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">nv</span><span class="op">)</span><span class="op">{</span>
    <span class="va">fm</span><span class="op">[</span><span class="va">s</span>,<span class="fl">1</span><span class="op">]</span>  <span class="op">=</span> <span class="va">s</span> <span class="op">-</span> <span class="fl">1</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">fm</span><span class="op">[</span><span class="va">s</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">minfm</span><span class="op">)</span><span class="op">{</span>
      <span class="va">minfm</span> <span class="op">=</span> <span class="va">fm</span><span class="op">[</span><span class="va">s</span>,<span class="fl">2</span><span class="op">]</span>
      <span class="va">nfact</span><span class="op">=</span> <span class="va">s</span><span class="op">-</span><span class="fl">1</span><span class="op">}</span>
  <span class="op">}</span>   
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span>OUT<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>name <span class="op">=</span> <span class="st">"MAP"</span>, nfact <span class="op">=</span> <span class="va">nfact</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Pour tester</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">MAP</span><span class="op">(</span>data<span class="op">=</span><span class="va">jd5000</span><span class="op">)</span>
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] "MAP"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $nfact</span>
<span class="co">#&gt; [1] 1</span></code></pre></div>
</div>
<div id="nest" class="section level2" number="1.13">
<h2>
<span class="header-section-number">1.13</span> NEST<a class="anchor" aria-label="anchor" href="#nest"><i class="fas fa-link"></i></a>
</h2>
<p>Le <em>Next Eigenvalue Sequential Test</em> développé par Achim <span class="citation">(<a href="r%C3%A9f%C3%A9rences.html#ref-Achim17" role="doc-biblioref">2017</a>, <a href="r%C3%A9f%C3%A9rences.html#ref-Achim20" role="doc-biblioref">2020</a>)</span> est le dernier cri en termes d’estimations du nombre de composante à retenir.</p>
<!-- Il est à mi-chemin entre MAP et AP  -->
<p><em>À terminer</em></p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">NEST</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">N</span><span class="op">=</span><span class="cn">NULL</span>, <span class="va">reps</span> <span class="op">=</span> <span class="fl">1000</span>, 
                 <span class="va">alpha</span> <span class="op">=</span> <span class="fl">.05</span>, <span class="va">convergence</span> <span class="op">=</span> <span class="fl">1e-5</span>, <span class="va">maxit</span> <span class="op">=</span> <span class="fl">500</span>, <span class="va">...</span><span class="op">)</span><span class="op">{</span>
  
  <span class="va">ns</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
  <span class="va">nv</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">ns</span><span class="op">==</span><span class="va">nv</span><span class="op">)</span><span class="op">{</span>
    <span class="kw">if</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/stop.html">stop</a></span><span class="op">(</span><span class="st">"Error: 'N' is required"</span><span class="op">)</span> 
    <span class="va">ns</span> <span class="op">=</span> <span class="va">N</span>
  <span class="op">}</span><span class="kw">else</span><span class="op">{</span>
    <span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>
  <span class="op">}</span> 
  <span class="va">E</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">data</span>, symmetric<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">values</span>
  
  <span class="kw">for</span> <span class="op">(</span><span class="va">nfact</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">nv</span><span class="op">-</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">{</span>
    <span class="va">rnk</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">nfact</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>
    <span class="kw">if</span> <span class="op">(</span><span class="va">nfact</span><span class="op">==</span><span class="fl">0</span><span class="op">)</span><span class="op">{</span>
      <span class="va">model</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">nv</span><span class="op">)</span>
    <span class="op">}</span><span class="kw">else</span><span class="op">{</span>
      <span class="va">R</span> <span class="op">=</span> <span class="va">data</span>
      <span class="va">pre</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>
      <span class="kw">for</span> <span class="op">(</span><span class="va">jj</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">maxit</span><span class="op">)</span><span class="op">{</span>
        <span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">R</span>, symmetric<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>
        <span class="kw">if</span> <span class="op">(</span><span class="va">nfact</span><span class="op">==</span><span class="fl">1</span><span class="op">)</span><span class="op">{</span>
          <span class="va">ld</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">values</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>
          <span class="va">co</span> <span class="op">=</span> <span class="va">ld</span><span class="op">*</span><span class="va">ld</span>
        <span class="op">}</span><span class="kw">else</span><span class="op">{</span>
          <span class="va">ff</span> <span class="op">=</span> <span class="va">nfact</span>
          <span class="kw">while</span> <span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">value</span><span class="op">[</span><span class="va">ff</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span><span class="va">ff</span> <span class="op">=</span> <span class="va">ff</span> <span class="op">-</span> <span class="fl">1</span><span class="op">}</span>
          <span class="va">ld</span> <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="va">ff</span><span class="op">]</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">values</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">ff</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>
          <span class="va">co</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span><span class="op">(</span><span class="va">ld</span><span class="op">*</span><span class="va">ld</span><span class="op">)</span>
        <span class="op">}</span>
        
        <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">co</span><span class="op">)</span><span class="op">&gt;</span><span class="fl">1</span><span class="op">)</span><span class="op">{</span>
          <span class="va">R</span> <span class="op">=</span> <span class="va">R</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">pre</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op">)</span>
          <span class="kw">break</span>
        <span class="op">}</span>
        
        <span class="va">diff</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">pre</span> <span class="op">-</span> <span class="va">co</span><span class="op">)</span><span class="op">)</span>
        <span class="kw">if</span> <span class="op">(</span><span class="va">diff</span> <span class="op">&lt;</span> <span class="va">convergence</span><span class="op">)</span> <span class="kw">break</span>
        <span class="va">R</span> <span class="op">=</span> <span class="va">R</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">co</span><span class="op">-</span><span class="va">pre</span><span class="op">)</span>
        <span class="va">pre</span> <span class="op">=</span> <span class="va">co</span>
      <span class="op">}</span>
      
      <span class="kw">if</span> <span class="op">(</span><span class="va">jj</span> <span class="op">&gt;=</span> <span class="va">maxit</span><span class="op">)</span><span class="op">{</span>
        <span class="va">nt</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="st">"Warning! Convergence not achieved"</span><span class="op">)</span>
      <span class="op">}</span>
      
      
      <span class="va">model</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">ld</span>, <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">co</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
    <span class="op">}</span>
    <span class="va">nd</span> <span class="op">=</span> <span class="va">nfact</span> <span class="op">+</span> <span class="va">nv</span>
    <span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">reps</span><span class="op">)</span><span class="op">{</span>
      <span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="va">ns</span> <span class="op">*</span> <span class="va">nd</span><span class="op">)</span>, <span class="va">ns</span>, <span class="va">nd</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">model</span><span class="op">)</span>, 
                  symmetric<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">values</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">nfact</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span>
      <span class="va">rnk</span> <span class="op">=</span> <span class="va">rnk</span> <span class="op">+</span> <span class="op">(</span><span class="va">res</span> <span class="op">&gt;=</span> <span class="va">E</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">nfact</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>
    <span class="op">}</span>
    <span class="kw">if</span> <span class="op">(</span><span class="va">rnk</span><span class="op">[</span><span class="va">nfact</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">alpha</span><span class="op">*</span><span class="op">(</span><span class="va">reps</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="kw">break</span>
  <span class="op">}</span>
  
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span>OUT <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>name <span class="op">=</span> <span class="st">"NEST"</span>, nfact <span class="op">=</span> <span class="va">nfact</span><span class="op">)</span>   <span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Pour tester</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">NEST</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">jd5000</span><span class="op">)</span>, N <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">jd5000</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] "NEST"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $nfact</span>
<span class="co">#&gt; [1] 2</span></code></pre></div>
</div>
<div id="packages" class="section level2" number="1.14">
<h2>
<span class="header-section-number">1.14</span> Packages<a class="anchor" aria-label="anchor" href="#packages"><i class="fas fa-link"></i></a>
</h2>
<p>La fonction <code><a href="https://rdrr.io/r/base/svd.html">svd()</a></code> a été abordée, mais d’autres fonctions peuvent aussi réaliser l’analyse en composantes principales, soit <code><a href="https://rdrr.io/r/stats/prcomp.html">prcomp()</a></code> et <code><a href="https://rdrr.io/r/base/eigen.html">eigen()</a></code>. Les sorties et arguments seront légèrement différents, mais correspondent aux mêmes analyses.</p>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="pr%C3%A9face.html">Préface</a></div>
<div class="next"><a href="solutions.html">Solutions</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#lanalyse-en-composantes-principales"><span class="header-section-number">1</span> L’analyse en composantes principales</a></li>
<li><a class="nav-link" href="#une-analogie-cuisinaire"><span class="header-section-number">1.1</span> Une analogie cuisinaire</a></li>
<li>
<a class="nav-link" href="#quelques-d%C3%A9finitions"><span class="header-section-number">1.2</span> Quelques définitions</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#les-valeurs-propres"><span class="header-section-number">1.2.1</span> Les valeurs propres</a></li>
<li><a class="nav-link" href="#les-loadings"><span class="header-section-number">1.2.2</span> Les loadings</a></li>
<li><a class="nav-link" href="#les-communalit%C3%A9s"><span class="header-section-number">1.2.3</span> Les communalités</a></li>
</ul>
</li>
<li><a class="nav-link" href="#cr%C3%A9ation-de-donn%C3%A9es"><span class="header-section-number">1.3</span> Création de données</a></li>
<li><a class="nav-link" href="#syntaxe"><span class="header-section-number">1.4</span> Syntaxe</a></li>
<li><a class="nav-link" href="#rotation-varimax"><span class="header-section-number">1.5</span> Rotation varimax</a></li>
<li><a class="nav-link" href="#dimensions-corr%C3%A9l%C3%A9es"><span class="header-section-number">1.6</span> Dimensions corrélées</a></li>
<li><a class="nav-link" href="#calculs"><span class="header-section-number">1.7</span> Calculs</a></li>
<li><a class="nav-link" href="#r%C3%A9duction-des-dimensions"><span class="header-section-number">1.8</span> Réduction des dimensions</a></li>
<li><a class="nav-link" href="#illustration"><span class="header-section-number">1.9</span> Illustration</a></li>
<li><a class="nav-link" href="#importance-dune-dimension"><span class="header-section-number">1.10</span> Importance d’une dimension</a></li>
<li><a class="nav-link" href="#lanalyse-parall%C3%A8le"><span class="header-section-number">1.11</span> L’analyse parallèle</a></li>
<li><a class="nav-link" href="#map"><span class="header-section-number">1.12</span> MAP</a></li>
<li><a class="nav-link" href="#nest"><span class="header-section-number">1.13</span> NEST</a></li>
<li><a class="nav-link" href="#packages"><span class="header-section-number">1.14</span> Packages</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/quantmeth/MQR/blob/master/14-ACP.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/quantmeth/MQR/edit/master/14-ACP.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Méthodes Quantitatives avec R</strong>" was written by P.-O. Caron. It was last built on 2022-05-20.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
