# (PART) Jeux de données {-}

# Entrer

S'il y a bien une caractéristique de **R** qui rebute les nouveaux utilisateurs, c'est certainement que le logiciel ne soit pas conçu pour la saisie de données ou, du moins, que cela ne soit pas mis en avant-plan. Lorsque le logiciel s'ouvre, que ce soit **R** ou **R**Studio, l'aspect *table de données* n'existe pas. Un tout nouvel utilisateur habitué aux logiciels traditionnels reste pantois : où sont les données?

Conceptuellement, **R** [importe][Importer] des données pour les manipuler. Elles ne sont pas entrées dans le logiciel. Il existe toutefois quelques méthodes pour ce faire, dont en voici une courte liste. **Ces méthodes sont présentées; elles ne sont pas recommandées**.
  
## `data.entry()` (`R-base`)

De base, **R** offre la possibilité d'entrer des données dans un tableur avec la commande `jd = data.entry()`. Si une base de données est demandée comme argument (p. ex., `data.entry(data = jd)`), alors le jeu de données s'ouvre. Il est aussi possible d'ouvrir le fichier avec des variables déjà créées avec **R**. Si un tableur vierge est désiré, alors il faut taper `data.entry(1)` dans la console pour ouvrir le tableur avec une seule valeur (`1`), L'utilisateur peut alors modifier les noms de colonnes et entrer les données comme dans un logiciel traditionnel. La Figure \@ref(fig:dataentry) montre l'interface bien moins attrayante que celles des compétiteurs.

```{r dataentry, fig.cap="Ouverture du tableur R",echo=FALSE, out.width="75%", fig.align="center"}
knitr::include_graphics("image//data_entry.PNG")
```

Lorsque l'entrée de données est terminée, l'utilisateur doit sauvegarder le jeu de données ou l'environnement de travail qui pourront être importés pour de futures utilisations ou entrées (voir la section [Sauvegarder un jeu de données]). En général, l'utilisateur qui entre manuellement ces données préférera certainement un autre tableur, puis [importer] ses données, mais **R** est certainement en mesure de faire ce travail. 

## `data_edit()` (`DataEditR`)

Comme il arrive régulièrement, un problème avec **R** se résout avec un package. Il existe un package qui permet de faire l'entrée de données en tableur avec **R**. Il s'agit du package `DataEditR` [@DataEditR], une interface utilisateur graphique. Il résout l'un de plus grands défis lorsqu'un utilisateur migre des tableurs traditionnels vers **R** : une feuille de calcul interactive où il est possible de pointer et cliquer pour modifier, ajouter, supprimer des donnes vers un mode strict de syntaxe.

Pour démarrer, il faut d'abord installer le package, puis l'appeler. Pour commencer à entrer des données, la syntaxe `data_edit()` est suffisante. Pour ouvrir un jeu de données, il suffit de l'ajouter en argument `data_edit(jd)`.

Une fois l'interface ouvert, il est possible de manipuler le jeu de données avec les options affichés et avec le clic droit qui permettra notamment d'ajouter des lignes et des colonnes.

```{r, eval = FALSE, warning=FALSE}
# Pour installer le package
install.packages("DataEditR")

# Pour rendre la package accessible
library("DataEditR")

# La fonction
data_edit()
```

Il est recommandé de ne laisser que les données brutes, toutes les modifications et manipulations doivent rester en syntaxe **R** dans un script associé au jeu de données. Lorsque les entrées sont terminées, sauvegarder la base de données, préférablement en extension .csv. Il est aussi possible de sortir le tableur en tableau de données en assignant la fonction à une variable comme `jd = data_edit()`.

```{r editr, fig.cap="Ouverture du tableur de DataEditR", echo=FALSE, out.width="75%", fig.align="center"}
knitr::include_graphics("image//editR.PNG")
```

En général, l'utilisateur doit [importer] ces données dans l'environnement **R**. Il faut même le faire avec `data_edit()` à chaque ouverture d'un nouvelle séance, pour poursuivre l'entrée ou réaliser des manipulations manuelles.